WEBVTT

00:00.890 --> 00:02.130
Selamat datang kembali.

00:02.150 --> 00:10.820
Mari kita bicara tentang lulus dengan referensi versus melewati nilai untuk menyelesaikan diskusi kita tentang tipe

00:11.030 --> 00:12.110
JavaScript.

00:12.230 --> 00:17.330
Sekarang di video sebelumnya saya mengatakan bahwa tipe primitif tidak dapat diubah.

00:17.330 --> 00:18.350
Apa artinya.

00:18.350 --> 00:23.090
Ya itu artinya kita tidak bisa mengubahnya untuk mengubahnya.

00:23.090 --> 00:31.140
Kita harus menghapus sepenuhnya tipe primitif dan katakanlah jika variabel A sama dengan lima.

00:31.220 --> 00:40.070
Nah agar saya dapat mengubah apa nilai lima itu, saya harus benar-benar memindahkannya dari memori dan membuat sesuatu yang

00:40.070 --> 00:49.020
baru seperti yang sama dengan 10 Saya benar-benar dapat memodifikasinya hanya sesuatu yang baru dibuat dan tipe primitif persis seperti

00:49.020 --> 00:57.480
itu ketika saya menetapkan sebuah variabel a hingga lima di suatu tempat dalam variabel memori akan berisi dan

00:57.480 --> 01:06.120
referensi nilai lima jika saya melakukan variabel B sama dengan dua katakanlah 10 lagi hal yang sama dan mereka

01:06.990 --> 01:10.390
tidak benar-benar mengetahui keberadaan satu sama lain.

01:11.230 --> 01:19.530
Ini adalah apa yang kita sebut dengan nilai objek, di sisi lain adalah apa yang kita sebut lulus dengan referensi, mari kita menulis

01:19.530 --> 01:22.550
beberapa kode untuk mencari tahu apa artinya ini.

01:22.650 --> 01:36.850
Jika saya melakukan variabel A sama dengan lima dan kemudian saya melakukan variabel B sama dengan 10 dengan baik sekarang memiliki alamat di mana

01:36.910 --> 01:41.450
nilai primitif lima ini berada dalam memori.

01:41.650 --> 01:49.450
Dan sama dengan bb memiliki alamat di mana nilai primitif 10 duduk di memori.

01:49.450 --> 01:50.880
Bagaimana jika saya melakukan B.

01:50.890 --> 01:53.090
Sangat Bobbie sama dengan dua.

01:53.160 --> 02:03.830
Hei apa yang terjadi kemudian ingat tipe primitif mereka dilewati oleh nilai ketika kita melewati nilai.

02:04.300 --> 02:08.350
Nah bagaimana jika saya melakukan sesuatu seperti B plus plus di sini.

02:08.350 --> 02:24.190
Jadi itu adalah menambahkan satu ke b jika saya konsol dot log a Saya memiliki lima dan jika saya konsol dot log BI memiliki enam dan ini adalah karena masa

02:24.310 --> 02:34.460
lalu dengan nilai semua yang saya lakukan atau semua mesin JavaScript lakukan adalah menyalin tipe nilai primitif lima sebagai

02:34.760 --> 02:45.180
jika saya melakukan B sama dengan lima sehingga sekarang B memiliki referensi ke nilai tipe primitif lima semua yang

02:45.390 --> 02:55.510
kita lakukan adalah menyalin nilai sehingga melihat diagram ini harus masuk akal setiap saat meskipun kita melakukan B

02:55.510 --> 03:06.650
sama dengan kita cukup menyalin nilai dan memasukkannya ke ruang memori baru di mesin kami mengingat tumpukan memori kami atau tumpukan

03:06.650 --> 03:14.900
kami di mana kami menyimpan informasi kami hanya membuat salinan mereka tidak benar-benar memiliki koneksi

03:14.900 --> 03:18.860
apa pun dan itulah yang dilewati.

03:18.860 --> 03:27.620
Nilai bertemu dengan nilai berarti kita menyalin nilai dan kita menciptakan nilai itu di tempat lain

03:27.620 --> 03:28.770
dalam memori.

03:28.900 --> 03:35.350
Sekarang mari kita lihat bagaimana objek berbeda tidak seperti apa yang kita

03:35.350 --> 03:46.240
miliki sebelumnya atau mari kita simpan ini di sini untuk saat ini agar Anda dapat melihat apakah saya membuat objek katakanlah

03:46.240 --> 03:57.120
Obyek 1 dan objek 1 memiliki nama Yao dan katakanlah ini adalah pengguna yang juga memiliki kata sandi dengan 1 2

03:57.120 --> 04:07.430
3 sebagai kata sandi super aman saya sekarang dan kita juga akan membuat objek lain membiarkan objek dan ini

04:08.240 --> 04:19.230
akan baik kita hanya bisa menyalin objek pertama sehingga objek ke objek yang satu harus sama benar tetapi bagaimana jika saya

04:19.410 --> 04:33.990
pergi ke depan dan dengan objek 2 saya mengubah kata sandi untuk peasy mudah apa yang akan terjadi maka jika saya konsol dialog objek 1 dan saya juga

04:35.010 --> 04:35.790
konsol

04:38.640 --> 04:51.900
log objek untuk dan saya menjalankan whoa apa yang baru saja terjadi kata sandi telah diubah kedua objek kata sandi seseorang dan kata sandi objek

04:51.900 --> 04:54.670
dua dimutakhirkan dengan melakukan ini.

04:56.190 --> 05:01.060
Dan ini karena untuk referensi.

05:01.110 --> 05:11.320
Anda melihat objek dalam javascript disimpan dalam memori dan diteruskan dengan referensi yang berarti bahwa kita tidak menyalin nilai-nilai

05:11.590 --> 05:15.450
seperti yang kita lakukan dengan tipe primitif.

05:15.760 --> 05:26.350
Kami hanya ketika kami menetapkan objek satu ke objek ke kami hanya mengatakan hei ini adalah tempat objek berada

05:26.380 --> 05:27.860
di memori.

05:27.910 --> 05:35.900
Jika kita kembali ke objek kode 1 dan objek 2 keduanya menunjuk ke suatu tempat di memori.

05:35.920 --> 05:36.840
Kami tidak tahu di mana.

05:36.880 --> 05:43.990
Di suatu tempat di memori menumpuk ke rak yang berisi informasi ini.

05:43.990 --> 05:54.930
Jadi yang saya lakukan dengan mengatakan objek sama dengan objek inginkan adalah hei ini katakanlah alamat dalam memori di

05:54.960 --> 05:57.450
mana pun ini berada.

05:57.720 --> 06:07.200
Jadi maksudnya adalah ketika saya mengubah objek dot kata sandi seperti ini saya katakan juga ubah kata sandi

06:07.440 --> 06:15.270
pada objek ini dalam memori yang juga objek satu menunjuk ke referensi yang berasal dari

06:15.270 --> 06:17.010
mana referensi berasal.

06:17.010 --> 06:19.890
Sekarang mengapa menurut Anda itu ide yang bagus.

06:19.930 --> 06:21.060
Mari kita pikirkan tentang ini.

06:21.060 --> 06:23.080
Mengapa ini bagus?

06:23.140 --> 06:26.150
Maksud saya itu agak benar, bagus.

06:26.230 --> 06:32.110
Karena dengan hanya memiliki satu objek di sini kita menghemat ruang dan memori.

06:32.110 --> 06:37.640
Kami tidak menyalin dan mengkloning objek yang membuat beberapa versi.

06:37.660 --> 06:46.240
Kami hanya dapat menyimpan referensi memori hanya satu lokasi daripada hanya memuat tumpukan memori kami.

06:47.050 --> 06:50.040
Tapi mengapa ini juga bisa buruk.

06:50.930 --> 06:58.100
Yah karena tidak seperti tipe primitif kita mungkin memiliki masalah ini di mana secara tidak sengaja

06:58.130 --> 07:02.180
orang lain mengubah properti pada objek yang dirujuk.

07:02.250 --> 07:07.450
Jadi ini adalah sesuatu yang perlu kita berhati-hati, mari kita lakukan contoh lain.

07:07.450 --> 07:12.930
Dan hanya untuk membuktikan seperti yang saya katakan sebelumnya bahwa array hanyalah objek.

07:12.940 --> 07:14.770
Mari kita coba ini dengan sebuah array.

07:15.460 --> 07:26.830
Jika saya melakukan variabel C dan variabel C ini memiliki satu dua tiga empat lima dan kemudian variabel D sama

07:28.480 --> 07:40.080
dengan C dan akhirnya kita akan mengatakan D dot mendorong beberapa angka raksasa di pastikan itu bukan angka string jika saya

07:40.080 --> 07:48.190
konsol log C atau mari kita konsol log D dulu dan saya jalankan ini.

07:48.620 --> 07:49.430
Saya melihat bahwa.

07:49.430 --> 07:49.770
Ya.

07:49.790 --> 07:58.160
Kami memodifikasi array tetapi karena array adalah objek yang dilewatkan oleh referensi C juga harus

07:58.160 --> 07:59.370
diubah benar.

07:59.460 --> 08:05.600
Pertarungan konsol log C dan saya menjalankan Yap C juga telah berubah juga kami melihat

08:08.510 --> 08:10.210
sesuatu di sini.

08:10.370 --> 08:11.000
Ini bagus.

08:11.000 --> 08:12.860
Kami sedang menghemat memori.

08:12.860 --> 08:14.930
Kami tidak hanya terus-menerus menyalin sesuatu.

08:14.930 --> 08:18.970
Bayangkan jika C adalah benda besar yang masif.

08:19.040 --> 08:26.440
Jika kita menyalin dua bagian kode yang berbeda setiap saat dengan baik.

08:26.690 --> 08:34.220
Ini akan membuat banyak memori tetapi kemudian ada saat-saat di mana kita mungkin ingin memiliki objek menyalinnya sehingga

08:34.220 --> 08:36.840
kita tidak memodifikasinya seperti ini.

08:37.610 --> 08:41.150
Bagaimana kita bisa melakukannya dengan baik dengan sesuatu seperti array.

08:41.180 --> 08:48.950
Ada berbagai cara untuk melakukannya, tetapi saya bisa melakukan array array kosong dan kemudian melakukan metode cone cat

08:49.070 --> 08:57.380
yang mendorong apa pun yang saya miliki di C ke array kosong ini sehingga ketika saya jalankan di sini Anda

08:57.470 --> 08:59.940
melihat bahwa C masih sama.

09:00.050 --> 09:04.010
Tetapi jika saya pergi ke D saya memiliki array baru.

09:04.010 --> 09:06.070
Itu kloning array.

09:06.350 --> 09:09.320
Objek sedikit lebih sulit.

09:09.410 --> 09:10.970
Katakanlah kita punya objek.

09:12.930 --> 09:20.480
Itu sama dengan satu katakanlah B adalah dua.

09:20.570 --> 09:30.350
Itu agak membingungkan mari kita lakukan dan kemudian B B dan akhirnya c sama dengan C

09:33.510 --> 09:37.780
dan objek ini saya ingin salin.

09:37.780 --> 09:40.750
Saya ingin memiliki kode ini.

09:40.750 --> 09:45.590
Objek ini berada di lokasi berbeda dalam memori.

09:45.610 --> 09:47.240
Bagaimana kita bisa melakukan itu.

09:47.260 --> 09:57.660
Yah saya tidak bisa melakukan objek lain seperti ini karena itu hanya akan melewati referensi dan kita masih akan

09:57.660 --> 10:05.830
mereferensikan objek yang sama sebagai gantinya kita dapat mengkloning objek dengan melakukan sesuatu

10:06.550 --> 10:15.920
seperti objek ini tanda di sini parameter pertama adalah objek yang akan disalin yang merupakan objek kosong.

10:16.030 --> 10:18.600
Lalu apa sumbernya.

10:18.610 --> 10:22.510
Jadi itu dari mana untuk menyalin properti.

10:22.510 --> 10:36.310
Jadi dalam kasus saya mereka akan menjadi objek sehingga sekarang jika saya mengubah katakanlah objek yang jauh lebih baru objek C sama

10:36.970 --> 10:49.090
dengan lima jika saya konsol dot log objek klon dan saya berjalan dengan baik saya membuat kesalahan besar.

10:49.090 --> 10:50.770
Ayo lihat di sini.

10:50.860 --> 10:54.220
Knife memiliki titik koma bukan koma.

10:54.330 --> 10:54.820
Itu dia.

10:55.080 --> 11:01.890
Jika saya menjalankan tampilan ini bahwa objek yang dikloning tidak terpengaruh sama sekali.

11:01.890 --> 11:04.940
Meskipun kami mengubah C menjadi lima.

11:05.580 --> 11:12.060
Ingat jika kita tidak melakukan ini, kita tidak mengkloningnya dan kita hanya melakukan objek yang akan

11:12.060 --> 11:17.770
dilewatkan dengan referensi dan kita akan melihat perubahan yang kita lihat di objek asli

11:17.770 --> 11:21.510
tetapi karena objek tanda kita dapat mengkloning objek.

11:21.540 --> 11:23.000
Sangat keren.

11:23.070 --> 11:28.110
Ada juga cara lain untuk melakukannya dan itu menggunakan operator spread.

11:28.170 --> 11:35.010
Saya bisa melakukan apalagi dua objek yang sama atau tidak benar-benar.

11:35.070 --> 11:46.180
Kami baru saja membuat objek dan kemudian melakukan dot dot dot dan kemudian objek bagus dan bersih dan ini adalah fitur baru yang kami

11:46.180 --> 11:53.590
dapatkan dalam bahasa javascript yang benar-benar sangat bagus dan sekali lagi jika saya menjalankan kode ini

11:53.590 --> 12:00.460
saya melihat clone hasn ' t telah dimodifikasi dan jika saya mengkloning ke yang

12:03.570 --> 12:11.280
belum dimodifikasi baik hanya untuk referensi saya akan menambahkan objek asli juga untuk melihat bahwa memang itu

12:11.670 --> 12:15.150
berbeda dari apa yang kita miliki sebelumnya.

12:15.180 --> 12:15.770
Luar biasa.

12:15.780 --> 12:23.220
Jadi kloning itu bagus tapi izinkan saya bertanya kepada Anda apa yang menurut Anda akan terjadi

12:23.700 --> 12:29.640
dengan kode yang kita miliki jika kita memiliki objek di dalam objek.

12:29.860 --> 12:39.220
Sebagai contoh jika C alih-alih hanya menjadi string adalah sebuah objek referensi referensi

12:39.220 --> 12:50.020
lain yang katakanlah memiliki kedalaman sebagai properti dan kedalaman ini akan sama dengan mencoba dan menyalin saya.

12:50.200 --> 12:51.100
Saya harap itu masuk akal.

12:51.100 --> 12:54.500
Biarkan saya menyesuaikan lekukan di sini sehingga Anda melihatnya lebih baik.

12:54.520 --> 12:56.840
Seperti apa yang terjadi.

12:57.030 --> 12:59.650
Jadi apa yang terjadi di sini.

12:59.700 --> 13:06.960
Kami memiliki objek yang direferensikan di suatu tempat di memori dan di dalam objek itu ada lagi

13:06.960 --> 13:14.170
pointer lain ke tempat lain di memori yang mereferensikan objek ini mari kita jalankan kode ini juga

13:17.870 --> 13:19.790
tidak ada yang berubah.

13:19.790 --> 13:20.380
Baik.

13:20.420 --> 13:23.690
Maksud saya C sudah jelas berubah dan.

13:23.960 --> 13:26.060
Nah itu sesuatu yang sudah kita lihat sebelumnya.

13:26.150 --> 13:37.120
Tapi bagaimana jika saya mengubah d kali ini alih-alih C Bagaimana jika saya melakukan objek dot c dot dalam dan

13:37.120 --> 13:50.630
dalam sekarang akan mengatakan hahaha apa yang menurut Anda akan terjadi di sini mari kita jalankan kode ini dan oh tidak, kita baru saja kita

13:51.230 --> 13:59.560
kloning semuanya tapi itu ditimpa saya pikir kami mengkloning semua yang terjadi di sini mengingat

13:59.920 --> 14:03.220
setiap objek dilewati oleh referensi.

14:03.370 --> 14:09.010
Jadi meskipun kita mengkloning objek objek awal.

14:09.280 --> 14:15.340
Ini adalah apa yang kita sebut klon dangkal itu klon tingkat pertama.

14:15.340 --> 14:24.100
Jadi itu adalah alamat memori di objek ini tetapi di dalam objek ini ada alamat lain ke objek

14:24.100 --> 14:24.690
lain.

14:24.700 --> 14:32.280
Jadi sekali lagi ingat ini hanyalah alamat lain yang kami punya di memori dan alamat ini.

14:32.310 --> 14:34.000
Yah itu tidak pernah berubah.

14:34.050 --> 14:37.200
Itu selalu mereferensikan objek ini.

14:37.260 --> 14:44.330
Jadi ini adalah kloning dangkal di mana kita hanya bisa mengkloning lapisan pertama.

14:44.390 --> 14:45.890
Itu masalah besar, benar.

14:45.890 --> 14:53.020
Bagaimana kita bisa melakukan kloning yang dalam dan cara kita melakukannya.

14:53.210 --> 15:06.770
Yah sedikit funky kita menggunakan Jason kita katakan biarkan super klon dan kita akan menggunakan metode Jason dot pass dan ini di luar

15:08.630 --> 15:10.820
ruang lingkup kursus.

15:10.820 --> 15:13.800
Anda dapat membaca apa yang dilakukan Jason pass.

15:13.940 --> 15:24.580
Tapi objek Jason ini akan mengatakan Jason dot stringy ify mari kita buat ini sedikit lebih besar.

15:24.590 --> 15:25.550
Ini dia.

15:25.550 --> 15:33.270
Kita akan merangkai ify yang mengubah semua yang ada di sini menjadi string dan kemudian setelah kita

15:33.270 --> 15:40.920
mengubah semuanya menjadi string kita akan melewatkannya dan mengubah string itu kembali menjadi objek sehingga jika

15:40.920 --> 15:41.490
saya

15:44.600 --> 15:55.530
melakukan super klon sekarang di bawah di sini mari kita lakukan super clone dan saya jalankan lihat itu coba dan salin saya super clone.

15:55.610 --> 15:58.540
Mari kita buat ini sedikit lebih kecil.

15:58.550 --> 15:59.320
Ini dia.

15:59.390 --> 16:09.340
Versi super clone melakukan clone yang dalam dari objek yang sangat sangat keren sekarang sebelumnya.

16:09.360 --> 16:13.740
Dan video ini saya harap diteruskan dengan referensi dan diteruskan dengan nilai masuk akal bagi Anda.

16:13.740 --> 16:16.720
Sekarang saya ingin memberi Anda sedikit peringatan.

16:16.800 --> 16:26.920
Namun, jika Anda melakukan kloning yang mendalam, Anda harus berhati-hati karena ini dapat memiliki beberapa

16:26.920 --> 16:33.720
implikasi kinerja jika objek ini sangat mendalam objek besar.

16:33.850 --> 16:38.240
Butuh waktu lama untuk mengkloning semuanya dengan benar.

16:38.320 --> 16:43.540
Jadi Anda tidak akan melihat ini terlalu banyak di alam liar jika Anda mengkloning objek seperti ini.

16:43.690 --> 16:47.320
Kemungkinan besar ada beberapa cara lain yang harus Anda lakukan.

16:47.410 --> 16:54.520
Tetapi saya ingin menunjukkan kepada Anda ide lewat referensi gagasan kloning dangkal kloning dalam

16:54.610 --> 17:01.590
dan beberapa cara yang bisa kita gunakan objek untuk mendapatkan yang diinginkan.

17:01.600 --> 17:03.790
Baiklah saya harap itu menyenangkan.

17:03.790 --> 17:05.820
Sampai jumpa di video berikutnya.

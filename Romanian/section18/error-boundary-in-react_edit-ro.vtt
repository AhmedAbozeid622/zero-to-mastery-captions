WEBVTT 00:01.650 -&gt; 00:10.830 Să adăugăm încă un instrument la cunoștințele noastre în React și React 16, care a fost o nouă versiune de reacție, a introdus ceva numit &quot;limite de eroare&quot; problema pe care a avut-o anterior React, care a fost 00:19.110 -&gt; 00:25.110 dacă ar exista un fel de eroare în cadrul unei componente, indiferent de motivul în care nu a existat un mod grațios de a trata aceasta. pe următoarea redați că veți obține toate aceste erori criptice și lucrurile nu ar funcționa bine. Pentru un utilizator 00:35.130 -&gt; 00:42.900 Vreți să vă asigurați că, chiar dacă o parte din arborele dvs. componentă se rupe, puteți avea încă o experiență uimitoare de UI, poate o bucată de textul care spune că ceva a mers prost, dar nu are pauză de aplicație. 00:48.780 -&gt; 00:54.520 Deci, în acest videoclip vom vorbi despre limitele de eroare și îl vom aplica aplicației noastre RoboFriends. 00:54.600 -&gt; 00:55.500 Să începem. 00:57.140 -&gt; 01:04.370 Primul lucru pe care vreau să îl fac este componenta pe care o voi adăuga un nou dosar și vom numi această componentă 01:04.760 -&gt; 01:13.330 ErrorBoundry.js și doar un memento de care aveți nevoie Reacționați 16 sau mai mult pentru ca aceasta să funcționeze. 01:13.430 -&gt; 01:21.930 Deci, asigurați-vă că în fișierul package.json aveți versiunea corectă a React. Acum, aici putem face componenta noastră importă regulată de import 01:28.960 -&gt; 01:33.620 și o importăm din pachetul de reacție. 01:34.050 -&gt; 01:41.000 Și, în sfârșit, avem o clasă de eroare care extinde componenta de reacție 01:43.830 -&gt; 01:45.840 și aici avem constructorul 01:48.960 -&gt; 01:noi numim super aici. 01:52.610 -&gt; 02:03.420 Și așa că avem acces la recuzită, va trebui să avem - în cadrul constructorului - paramaterul de recuzită. 02:03.560 -&gt; 02:11.880 Și apoi, în sfârșit, pentru acest stat vom crea o proprietate numită hasError. 02:12.370 -&gt; 02:16.190 Și pentru moment va fi falsă. 02:26.520 -&gt; 02:26.310 Și să nu uităm de asemenea să exportim eroarea implicită ErrorBoundry, așa că avem acces la ea și avem renderul nostru implicit 02:26.520 -&gt; 02:29.760 care ne va reveni. 02:30.830 -&gt; 02:32.760 Ce ar trebui să se întoarcă. 02:33.170 -&gt; 02:41.300 Ei bine, cu această componentă ErrorBoundry putem împacheta componenta sau putem împacheta o componentă ca componentă CardList cu o componentă ErrorBoundry și dacă componenta CardList eșuează putem 02:48.890 -&gt; 02:51.340 să-l prindem în &quot;ErrorBoundry&quot;. 02:52.390 -&gt; 02:57.790 Știu că este puțin greu de urmat. React are o documentație foarte bună în acest sens, așa că poți să citești întotdeauna mai târziu acest lucru 02:57.790 -&gt; 02:59.520. 02:59.530 -&gt; 03:01.150 Dar stai cu mine. 03:01.150 -&gt; 03:03.220 Credeți-mă că va avea sens. 03:03.220 -&gt; 03:14.080 Deci, primul lucru pe care dorim să-l facem este că vrem să verificăm dacă this.state.hasError este egal cu adevărat. 03:14.150 -&gt; 03:23.000 Deci, dacă există un fel de eroare, atunci vrem să întoarcem această stare implicită a modului în care putem grațios să afișăm ceva utilizatorului, ceea ce o face semnificativ pentru ei, chiar dacă nu am putut afișa ceea ce ne-am propus inițial. 03:32.040 -&gt; 03:44.590 În cazul nostru, putem spune că avem un <h1> din &quot;Oooops&quot;, ceea ce nu este bun &quot;pentru utilizator. 03:44.620 -&gt; 03:52.760 Deci, spunem aici că dacă, din anumite motive, există o eroare, vom scuipa o etichetă h1. 03:53.940 -&gt; 03:54.870 Altfel, 03:55.100 -&gt; 03:58.460 și putem face o revenire aici. 03:58.560 -&gt; 04:06.150 Vom spune că aceștia vor face, reamintesc din nou - pentru că copiii vor fi ceva între Eroare. 04:09.090 -&gt; 04:16.050 În cazul nostru va fi, probabil, CardList. Deci fă copiii, tot ce este înăuntru 04:16.140 -&gt; 04:17.410 din ErrorBoundry, 04:17.470 -&gt; 04:19.330 altfel face <h1> . 04:19.710 -&gt; 04:28.390 Acum, cum vom putea schimba acest lucru? Ei bine, cu React 16 avem o nouă metodă de ciclu de viață 04:28.390 -&gt; 04:38.270 introdusă și se numește componentDidCatch și această componentăDidCatch este de tip 04:38.270 -&gt; 04:49.390 cum ar fi încercați blocul de blocare din javascript dacă orice eroare se va executa acest cârlig ciclului de viață și acest cârlig de viață 04:49.400 -&gt; 04:52.420 de fapt, devine un cuplu de parametri. 04:52.450 -&gt; 04:55.690 Aceasta este eroarea și informațiile. 04:55.830 -&gt; 05:03.540 Dar, în cazul nostru, vrem să spunem că acest set.setState va merge acum, dacă această eroare 05:03.590 -&gt; 05:08.230 va avea o eroare egală cu Adevărat. 05:08.280 -&gt; 05:13.760 Deci, dacă s-ar fi declanșat vreodată, urma să se facă eticheta H-1. 05:13.870 -&gt; 05:14.190 În regulă. 05:14.230 -&gt; 05:17.490 Să salvăm și să mergem la app.js 05:17.580 -&gt; 05:20.730 Să importăm eroarea noastrăBoundry 05:25.190 -&gt; 05:26.630 de la componentele noastre. 05:32.210 -&gt; 05:34.030 Și acum putem folosi asta. 05:34.100 -&gt; 05:38.740 Să o folosim aici pentru lista de carduri. 05:38.900 -&gt; 05:46.370 Deci, dacă se întâmplă ceva cu CardList, vrem să avem o limită de ieșire grațioasă. 05:46.580 -&gt; 05:55.340 Deci, vom spune &quot;ErrorBoundary&quot; și pentru că noi redăm acest punct de recuzită pentru copii, dacă o împachetăm ca pe asta 05:55.340 -&gt; 05:55.970. 05:57.250 -&gt; 06:00.450 Și nimic nu se întâmplă că va face încă CardList. 06:00.490 -&gt; 06:03.030 Hai să salvăm Să vedem dacă am făcut greșeli. 06:03.130 -&gt; 06:04.570 Atât de bine. 06:04.690 -&gt; 06:08.320 Să ne întoarcem la aplicația noastră și. 06:08.380 -&gt; 06:10.400 Să ne uităm la consola. 06:10.410 -&gt; 06:17.280 Nu există erori aici, dacă nu reîmprospătează nici o eroare aici dacă scriu chestii, nu erori, asta e bine. 06:19.190 -&gt; 06:26.840 Acum, cu această limită de eroare, dacă ceva din CardList nu reușește, o să o prinde și să afișeze mesajul nostru de eroare 06:26.840 -&gt; 06:28.000. 06:28.070 -&gt; 06:29.420 Să vedem ce vreau să spun. 06:29.710 -&gt; 06:39.420 Dacă intru în CardList aici și acum aici, dacă spunem, dacă deocamdată vom spune adevărat. 06:39.660 -&gt; 06:48.440 Vom presupune că în CardList a existat o eroare, așa că putem face asta spunând arunca o nouă eroare și spunem &quot;NOOOOOOO&quot; 06:51.790 -&gt; 06:54.850 acest lucru, totul funcționează încă. 06:54.850 -&gt; 06:59.750 Dacă mă întorc să vedeți că încă mai primesc eroarea, se spune că eroarea nu este acoperită. 06:59.800 -&gt; 07:00.620 07:00.910 -&gt; 07:07.030 Și în partea de jos se spune că eroarea de mai sus a apărut în componenta CardList. React va încerca să recreeze 07:07.030 -&gt; 07:11.950 acest copac component de la zero utilizând eroarea pe care ați furnizat-o. ErrorBoundry. 07:12.360 -&gt; 07:16.670 OK, asta e minunat, dar eu încă văd eroarea. 07:16.900 -&gt; 07:23.770 Și asta pentru că ne aflăm acum în modul de dezvoltare. Pentru a crea reacția aplicației. 07:23.770 -&gt; 07:29.780 Ei vor să ne arate ori de câte ori există o eroare în componenta noastră. Limitele de eroare sunt cu adevărat utile când 07:29.780 -&gt; 07:38.750 ați pus aplicațiile în producție unde nu aveți aceste jurnale detaliate despre erorile pe care le aveți. Utilizatorii tăi 07:38.750 -&gt; 07:40.540 nu vor vedea niciodată acest lucru. 07:40.550 -&gt; 07:45.040 Deci, dacă vă reîmprospătesc foarte repede, vedeți asta chiar aici. 07:45.050 -&gt; 07:48.320 Cum sa spus - Oooops, care nu este bun. 07:48.470 -&gt; 07:49.010 Oops. 07:49.100 -&gt; 07:50.450 Nu este bine. 07:50.450 -&gt; 07:54.820 Deci, în producție, utilizatorii vor vedea asta. 07:55.040 -&gt; 08:01.640 Dar pentru cazul nostru, comportamentul intenționat de a crea React App în dezvoltare este să ne arătăm erorile 08:01.910 -&gt; 08:05.770 dar cu limite de eroare avem această siguranță suplimentară în timpul producției. 08:07.830 -&gt; 08:08.890 Asta e deocamdată. 08:08.890 -&gt; 08:10.800 Voi vedea în următoarea. Pa! Pa.
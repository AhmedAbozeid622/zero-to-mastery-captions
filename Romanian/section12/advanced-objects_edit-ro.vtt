WEBVTT

00:01.270 --> 00:02.500
Bine ai revenit.

00:02.500 --> 00:06.490
Vom vorbi despre câteva concepte avansate de obiecte.

00:06.490 --> 00:13.840
Acum, așa cum am spus, cu atât matrice, cât și funcții, acestea sunt concepte avansate, probabil că nu veți merge

00:13.840 --> 00:21.490
doar pentru prima dată în jur de 100%, dar folosiți aceste videoclipuri ca o referință pentru a reveni ca tine

00:21.490 --> 00:22.980
progresează prin cariera ta.

00:24.250 --> 00:30.020
Acum, în acest videoclip, voi vorbi despre trei lucruri importante cu obiectele.

00:30.110 --> 00:35.260
Vom vorbi despre "tipul de referință".

00:35.350 --> 00:38.040
Vom vorbi despre "context".

00:38.620 --> 00:41.350
Și în sfârșit vom vorbi despre "instanțiere".

00:45.000 --> 00:51.690
Deci, să începem cu prima linie. "tip de referință". Ce vreau să spun când spun un "tip de referință"?

00:51.690 --> 00:58.810
Ei bine, am vrut să văd dacă pot ghici ce se va întâmpla atunci când fac matricea "[]" este egală cu "[]".

00:58.830 --> 01:00.530
Care credeți că va fi răspunsul?

01:00.570 --> 01:02.860
Sa vedem.

01:02.890 --> 01:05.930
Hmm! interesant.

01:05.930 --> 01:14.160
OK, ce dacă fac matricea este egală cu matricea 1? interesant.

01:14.260 --> 01:15.270
OK încă o întrebare.

01:15.550 --> 01:18.280
Ce zici de ceva de genul asta?

01:19.650 --> 01:20.620
'Object1'

01:21.060 --> 01:25.090
este egal cu valoarea de 10,

01:29.230 --> 01:37.220
și vom spune că 'object2' este egal cu 'object1'.

01:39.120 --> 01:49.450
Și vom spune în sfârșit că o variabilă (var) 'object3' este egală cu valoarea 10.

01:49.460 --> 01:54.710
Deci, uita-te la acestea și de fapt o voi copia aici, ca să vezi și ea.

01:59.260 --> 02:00.180
Privind la acest lucru,

02:00.310 --> 02:07.420
Ce se întâmplă dacă fac obiect1 egal cu 'object2'?

02:07.450 --> 02:08.510
Ce crezi ca se va intampla?

02:09.560 --> 02:10.100
Adevărat.

02:10.300 --> 02:10.750
O.K.

02:10.880 --> 02:15.580
Acest lucru are sens, vreau să spun că "obiect2" este "obiect1".

02:15.760 --> 02:22.780
Dar dacă fac obiect1 este egal cu 'object3'.

02:22.860 --> 02:25.710
Iată-mă, falsă.

02:25.900 --> 02:29.160
Dar de ce este asta? Avem valoarea 10, valoarea 10.

02:29.180 --> 02:30.990
Sunt ambele aceleași lucruri.

02:31.240 --> 02:32.060
Dreapta.

02:32.460 --> 02:33.190
Să verificăm altceva.

02:33.200 --> 02:37.010
Ce se întâmplă dacă fac "object1.value"

02:38.230 --> 02:42.430
este egal cu 15, OK.

02:42.610 --> 02:45.340
Și acum fac "object2.value"

02:48.390 --> 02:50.020
este egal cu 15.

02:50.150 --> 02:59.590
Dar dacă fac "object3.value", obțin 10. Asta a fost confuz corect.

03:00.000 --> 03:02.280
Să ne uităm la ceea ce se întâmplă de fapt.

03:02.430 --> 03:07.010
Acesta este primul subiect despre care vorbim despre "tipul de referință".

03:07.110 --> 03:08.220
Să ne uităm la o diagramă.

03:11.020 --> 03:16.700
Obiectele sunt numite "tipurile de referință" în Javascript.

03:16.940 --> 03:25.000
Până în acest moment, toate celelalte tipuri de javascript pe care le-am învățat, inclusiv "numere", "null", avem

03:27.530 --> 03:39.610
"nedefinite", "booleani", "șiruri de caractere" și chiar "simboluri", toate acestea sunt definite de limbajul de programare.

03:39.600 --> 03:48.150
Deci, Javascript, persoana care a scris javascript și ECMAScript standardul spune că acestea sunt tipuri primitive.

03:48.150 --> 03:57.990
Noi vă spunem ce sunt. Acum, un "tip de referință" care este un tip non primitiv nu este definit de către

03:57.990 --> 03:59.900
limbaje de programare.

03:59.910 --> 04:06.380
Ce înseamnă asta este că sunt create de programator.

04:06.410 --> 04:08.750
Asa ca sa privim aici ca un exemplu.

04:09.760 --> 04:10.930
Când spun varianta.

04:10.930 --> 04:13.200
Numărul unu este egal cu unul.

04:13.330 --> 04:15.170
Javascript știe ce este.

04:15.170 --> 04:16.470
E un număr.

04:16.480 --> 04:17.500
E un tip primitiv.

04:17.500 --> 04:19.450
Este întotdeauna același lucru.

04:19.590 --> 04:25.340
Este imutabilă de fiecare dată când folosește aceia pe care îl știe despre javascript.

04:25.460 --> 04:31.460
Când fac numărul variabil de două, da, folosește același număr pentru care știe javascript.

04:33.260 --> 04:40.750
Cu toate acestea, atunci când am creat 'object1' este egal cu 'value 10' și 'object2' este egal cu 'object1' și 'object3'

04:40.770 --> 04:45.620
"valoarea 10", și acestea sunt create de programator.

04:45.630 --> 04:47.190
Există "tipuri de referință".

04:47.190 --> 04:55.310
Așadar, ceea ce am spus a fost că vreau ca "obiect1" să creeze un obiect nou, să spună această cutie aici de aici

04:56.560 --> 05:06.590
și în ea, puneți "valoarea 10" în această căsuță. 'object2' spune, vreau doar sa te referi si asta e locul unde

05:06.590 --> 05:07.680
vine cuvântul,

05:07.760 --> 05:19.360
referință 'object1', spunând hei! Vreau tot ce se află în cutia asta. Când 'object3' devine creat,

05:19.470 --> 05:22.770
este un obiect nou pentru că avem noile paranteze.

05:23.660 --> 05:27.770
Și spune că puneți "valoarea 10" în această căsuță.

05:27.770 --> 05:35.320
În esență, ceea ce facem este să spunem atunci când creăm un obiect variabil (var) atunci când stocăm doar o referință

05:35.330 --> 05:40.520
o adresă în care stocăm "valoarea 10" care este "Box1".

05:40.520 --> 05:43.780
Deci, spunem 'object1',

05:43.970 --> 05:49.660
Vă anunț doar că aceasta este adresa întregului conținut pe care îl doriți

05:49.730 --> 05:55.710
și asta e în 'Box1'. 'object2' spune, vreau orice este un 'object1'

05:55.730 --> 06:01.220
și căutăm un 'object1', un 'object1' are doar informația despre 'box1'.

06:01.430 --> 06:08.110
Deci, se referă la faptul că un 'object3' creează un obiect nou.

06:08.120 --> 06:15.140
Deci, spune, voi pune conținutul meu în "Box3" și voi avea adresa casetei

06:15.470 --> 06:18.070
spunând "Box3" care este chiar aici.

06:19.500 --> 06:21.090
Deci, revenind la exemplul nostru,

06:24.280 --> 06:28.040
acest lucru are sens atunci când schimbăm valoarea 'object1' la 15,

06:28.090 --> 06:31.150
modificăm conținutul "Box1".

06:31.150 --> 06:39.330
Deci, atunci când facem 'object2.value' care se referă la aceeași casetă ca și 'object1' care este 15,

06:39.340 --> 06:45.730
dar "object3.value" nu se schimbă pentru că asta e interesat de o cutie complet diferită, este 'Box3'

06:46.720 --> 06:48.740
și revenind la primul exemplu.

06:50.920 --> 06:58.970
Arrays, așa cum am menționat și în videoclipurile anterioare, matricele sunt doar obiecte la sfârșitul zilei.

06:59.090 --> 07:05.220
Deci, atunci când creați o matrice, este același lucru, creând o casetă, o structură de date.

07:05.510 --> 07:09.100
Și aceasta este crearea unei a doua structuri de date.

07:09.120 --> 07:09.800
Dreapta.

07:09.860 --> 07:16.820
Deci, acesta este un "tip de referință". Un concept foarte important, dar cred că, cred că ai dreptate.

07:17.670 --> 07:18.980
Să trecem la următoarea.

07:18.990 --> 07:21.010
Acest lucru devine puțin mai complicat.

07:21.060 --> 07:30.090
Acest context numit "context" și "context" se confundă foarte mult cu "domeniul de aplicare".

07:30.190 --> 07:37.230
Dacă vă amintiți, am spus că "domeniul de aplicare" este creat atunci când vede paranteze curry, dreapta !.

07:37.270 --> 07:45.040
Am spus că, dacă creăm o funcție, de îndată ce vom crea acea funcție

07:45.040 --> 07:45.880
există un nou "domeniu de aplicare" care este creat.

07:46.450 --> 07:57.550
Așa că putem avea, "să fie" egal cu "a" și să trăiască în acest univers.

07:57.560 --> 08:02.180
Nu știe nimic despre scopul rădăcinii care este aici.

08:02.180 --> 08:06.680
Deci, dacă fac "console.log (a)", nu va funcționa.

08:06.880 --> 08:11.940
Oh! și trebuie să atribuim ceva și trebuie să-l numim ca să spunem "b".

08:12.320 --> 08:16.380
Deci, dacă fac acest lucru, bine "console.log (a)".

08:16.590 --> 08:20.710
bine, întoarceți "ReferenceError" deoarece nu există.

08:20.810 --> 08:22.370
Deci, asta e "domeniul de aplicare".

08:22.400 --> 08:31.520
Acum cum este diferit contextul? "context" vă spune, unde suntem în interiorul obiectului.

08:31.520 --> 08:32.650
Lasă-mă să explic.

08:32.990 --> 08:38.760
Dacă spunem "console.log (this)".

08:39.110 --> 08:45.350
Ei bine, vedeți, voi obține o evidențiere, și aceasta este prima dată când vedem "acest",

08:45.350 --> 08:46.340
și este un cuvânt special în javascript.

08:46.340 --> 08:52.220
Probabil cel mai confuz cuvânt pe care o mulțime de oameni au probleme și chiar oameni pe care am fost în

08:52.220 --> 08:57.150
industria de ani de zile încă mai are un timp dificil cu "acest". Dar să vedem ce este.

08:57.560 --> 09:03.950
"acest lucru" este, după cum puteți vedea, "obiectul ferestrei".

09:03.990 --> 09:14.610
Deci, doar pentru a verifica dublu, dacă fac "console.log (acest)" egal "fereastră", eu devin adevărat.

09:14.840 --> 09:23.990
Și pot accesa 'this.alert ("hello")'

09:24.030 --> 09:35.670
Deci, ce înseamnă "acest", este ceea ce este obiectul mediului în care suntem acum, cel mai bun mod de a gândi este,

09:35.670 --> 09:42.500
ce este la stânga punctului?

09:42.510 --> 09:49.860
Deci, acum pot să fac "alertă" deoarece sunt în interiorul "obiectului ferestrei".

09:50.190 --> 09:54.060
Deci, a face "fereastră" sau a face "acest" este același lucru.

09:54.210 --> 09:57.170
De ce este important acest lucru?

09:57.330 --> 10:04.110
Atunci când ajungem la "instanțiere", vă voi arăta de ce este? dar este un concept foarte important

10:04.110 --> 10:05.490
că veți vedea din nou și din nou.

10:05.550 --> 10:17.440
Dar amintiți-vă, "acest" se referă doar la obiectul în care se află. Încă două exemple pentru a demonstra "acest lucru".

10:17.480 --> 10:23.450
Una este, dacă eu "funcționează a ()", cu funcția "a",

10:26.240 --> 10:29.140
va spune "console.log (this)".

10:29.170 --> 10:30.840
Deci, dacă numesc "a", ce crezi că se întâmplă?

10:33.620 --> 10:35.660
Sa vedem. încă fereastra obiect "acest"

10:35.660 --> 10:39.280
încă se referă la funcție.

10:39.410 --> 10:47.240
Și dacă vă aduceți aminte că este pentru că am spus, trebuie să fie obiectul în care suntem înăuntru de acum.

10:47.240 --> 10:47.970
Funcția tehnică "a".

10:48.020 --> 10:52.260
Pot să merg "window.a" și să execut funcția.

10:52.520 --> 11:02.940
Deci, la stânga punctului, asta e "fereastra", pentru a crea o nouă valoare pentru "acest".

11:03.070 --> 11:06.450
Trebuie să faci așa ceva.

11:10.430 --> 11:13.560
'obiect', 'a' funcție 'a'.

11:13.580 --> 11:14.960
Acum, dacă fac "funcția ()"

11:19.930 --> 11:23.240
și în interiorul meu fac un "console.log (acest)".

11:23.230 --> 11:32.550
Ei bine, în acest caz, dacă copiați acest lucru și rulați 'object4.a'

11:35.600 --> 11:36.340
Bine,

11:36.620 --> 11:45.780
Acum acesta este obiectul, care este 'object4'.

11:45.850 --> 11:49.910
Deci, de ce este important pentru noi?

11:50.080 --> 11:54.510
În primul rând, o veți vedea în alte coduri, deci este bine să știți.

11:54.730 --> 12:01.840
Dar este foarte important când facem "instanțiere", "instanțiere" este când faceți o copie a unui obiect

12:02.470 --> 12:05.320
și reutilizați codul.

12:05.320 --> 12:11.950
Imaginați-vă că construiți un joc online multiplayer mare și acest joc va avea mulți jucători mulți

12:11.950 --> 12:17.170
puteți avea vrăjitori puteți avea trolls, warlocks, elfii.

12:17.200 --> 12:24.130
Acum, dacă a trebuit să creați un obiect pentru fiecare jucător care are multe coduri repetate,

12:24.130 --> 12:28.040
este o mulțime de hassle și bine, că este o mulțime de timp și nu este foarte eficient.

12:29.410 --> 12:32.320
Pentru a rezolva asta, puteți face ceva numit "instanțiere".

12:32.320 --> 12:37.490
Faceți instanțe sau copii multiple ale unui obiect.

12:37.510 --> 12:42.990
Așadar, permiteți-mi să vă arăt cum facem "instanțierea" în javascript.

12:43.040 --> 12:49.340
Din nou, acest lucru va arăta, un pic ciudat la început, la fel ca "pentru" bucle au făcut, la fel ca "funcții" a făcut

12:49.340 --> 12:54.000
la început, dar este doar sintaxa și vă veți obișnui.

12:54.380 --> 12:59.290
Deci, să spunem că avem o clasă "Jucător".

12:59.430 --> 13:05.540
Acum vedeți noua sintaxă nouă și capitalizez o "clasă".

13:05.590 --> 13:10.060
Acum, gândiți-vă la o "clasă" ca la ceva la care vreau să fac o copie.

13:10.210 --> 13:18.130
Dacă vreau vreodată să fac o copie a unui "obiect", este o idee bună să faceți ceva de genul acesta, așa că bine, veți

13:18.130 --> 13:20.060
vedeți cât de ușor este să copiați acum acest lucru.

13:20.070 --> 13:22.000
Deci noi facem.

13:22.010 --> 13:23.680
"jucător de clasă".

13:25.650 --> 13:28.650
Și aici, va spune "constructor"

13:31.360 --> 13:35.570
și știu că acest lucru pare ciudat, dar din nou este doar o sintaxă.

13:35.590 --> 13:45.650
Să o dăm, acest "Jucător" poate avea un "nume" și un "tip" și în constructorul "this.name" este egal

13:45.740 --> 13:51.350
"nume" și "acest tip" este egal cu "tipul".

13:55.940 --> 13:58.150
Oh baiete! Ce sa întâmplat aici.

13:58.160 --> 14:00.890
"constructor", când creați o "clasă", spuneți un "jucător", "clasă".

14:01.190 --> 14:08.330
De fiecare dată când fac o copie a unui "Player", primul lucru care se execută este funcția "constructor" și

14:08.330 --> 14:14.760
această funcție "constructor" va crea aceste proprietăți în obiectul "Player".

14:14.990 --> 14:17.530
Deci "nume" și "tip".

14:17.660 --> 14:21.500
Și acum pot crea orice vreau pentru "Jucător".

14:21.500 --> 14:30.730
Să presupunem că vrem să creăm o metodă precum 'introduce ()' că 'console.log (s)'

14:33.650 --> 14:42.980
cu spate ticks (`), 'Hi I'm' și, din nou, dacă vă amintiți șirul de șablon de sintaxă,

14:43.420 --> 14:54.190
'this.name', 'I'm a', 'this.type'. Minunat!

14:54.280 --> 15:02.560
Deci, acum spun, această clasă "Jucător", orice jucător pe care îl creez va fi întotdeauna capabil să se prezinte și să se prezinte

15:02.560 --> 15:07.880
ei vor avea de asemenea "acest" nume "și" acest tip ".

15:07.900 --> 15:14.930
Iar motivul pentru care folosim acest lucru este că atunci când creăm un "Player", putem accesa numele și tipul proprietății.

15:14.980 --> 15:17.090
Îți voi arăta mai târziu cum funcționează.

15:17.320 --> 15:24.580
Dar aceasta este doar sintaxa cu care vă veți obișnui. Pentru a avea acces

15:24.580 --> 15:25.090
"Playerul" și faceți copii ale acestuia.

15:25.120 --> 15:29.290
Va trebui să rulați un "constructor" care reprezintă toate proprietățile și metodele

15:29.290 --> 15:29.970
pe care doriți să o aibă "Jucătorul".

15:30.250 --> 15:38.680
De asemenea, puteți crea metode pe care "Jucătorii" le pot avea și oricând doriți să accesați o proprietate

15:38.680 --> 15:47.160
în cadrul "constructorului" folosiți bine "this.name" pentru (dacă vreau să folosesc "introduce" va trebui să fac "this.introduce".

15:47.190 --> 15:54.030
OK, deci avem un "Jucător", dar când construim jocul nostru multiplayer

15:54.030 --> 15:54.650
vrem să copiem acum, dar să adăugăm pe ea.

15:54.750 --> 15:59.470
Să spunem că avem ceea ce vrem să creăm un jucător de vrăjitor, un jucător care este un vrăjitor.

15:59.520 --> 16:00.570
În acest caz, am face,

16:00.570 --> 16:04.010
"Class Wizard" din nou scrisoarea de capital

16:05.030 --> 16:10.780
"extinde" și din nou este doar cuvântul cheie "Player" din javascript.

16:13.400 --> 16:14.260
Deci, ce este această vorbă?

16:14.270 --> 16:19.340
Vreau să spun că vreau ca "vrăjitorul" să extindă tot ce are "Jucătorul".

16:19.340 --> 16:26.540
Deci, vreau să adaug pe partea de sus a oricăror "Jucători", din nou pentru că este o "clasă", trebuie să fac un "constructor".

16:28.410 --> 16:35.700
Iar acest "Vrăjitor" va accepta "nume" și "tip", iar aici, aceasta este partea complicată.

16:35.700 --> 16:45.480
Ori de câte ori extindem ceva, trebuie să numim și funcția "constructor" a "Jucătorului".

16:45.480 --> 16:52.010
Trebuie să facem ceva numit "super" cu proprietățile pe care vrem să le trecem la "constructor".

16:52.080 --> 17:01.040
În acest caz, "nume" și "tip", știu că acest lucru este confuz, este doar ceva ce trebuie să faceți,

17:01.340 --> 17:02.410
ori de câte ori "extindeți" o clasă,

17:02.630 --> 17:09.450
doriți să utilizați super-urile, astfel încât în ​​esență să aveți acces la acestea.

17:09.460 --> 17:14.440
Bine, deci să spunem că, cu vrăjitorul, dorim să avem și o funcție de "joc".

17:14.620 --> 17:18.600
Și funcția "play" a fost doar un "console.log".

17:19.060 --> 17:30.640
"WEEEEEE Sunt", "acest" tip și acum că avem vrăjitorul nostru, care este puterea?

17:30.640 --> 17:31.340
Care este motivul pentru care am făcut asta?

17:31.360 --> 17:37.340
Acum putem face asta, în loc să creăm în mod constant "Jucători" și apoi să spunem că au Wizards

17:37.450 --> 17:38.760
și pot juca.

17:38.770 --> 17:49.360
Acum pot spune că 'wizard1' este egal cu 'new' 'Wizard' și vom apela din nou primul asistent.

17:49.370 --> 17:50.830
Obținem "nume" și "tip".

17:51.210 --> 17:58.220
Așa că vom spune "Shelly" și ea va fi "Vindecător".

18:00.220 --> 18:15.990
Și dacă vreau să creez un nou vrăjitor, voi spune că 'wizard2' este egal cu 'new' 'Wizard' 'Shawn' și el este 'Dark Magic'.

18:16.270 --> 18:23.120
Ooh !, A fost o sintaxă nouă, așa că hai să trecem prin ea și să ne asigurăm că înțelegem totul.

18:23.610 --> 18:29.010
După cum am aflat, hai să folosim jurnalul de console (console.log) pentru a înțelege cu adevărat ce facem.

18:29.010 --> 18:34.240
Voi adăuga un jurnal de console (console.log) chiar deasupra aici.

18:36.240 --> 18:37.620
Și va spune "asta".

18:37.640 --> 18:38.730
Ce este asta'.

18:39.950 --> 18:46.950
Am de gând să salvez și, de fapt, voi copia asta în consola.

18:47.150 --> 18:48.010
Să o copiem.

18:49.100 --> 18:51.570
Și vezi ce ne dă jurnalul de consolă?

18:51.570 --> 18:54.430
Vedem că avem "Wizard".

18:54.530 --> 18:56.220
În regulă, să trecem prin toate.

18:57.580 --> 19:02.440
Spun, avem un "jucător de clasă", apoi un "expert de clasă" care extinde "jucătorul".

19:02.830 --> 19:07.440
Și apoi avem două variabile pe care le-am creat "wizard1" și "Wizard2".

19:07.480 --> 19:14.350
Acum, programul va vedea cuvântul cheie "nou" și oricând va vedea un cuvânt cheie "nou" se spune, oh! suntem

19:14.350 --> 19:23.810
creând un nou "Expert" și acest "Expert" va avea doi parametri "Shelly" și "Healer".

19:23.860 --> 19:30.280
Deci, va merge din nou la clasa "Wizard" pentru că are acest cuvânt "nou".

19:30.310 --> 19:38.740
Merge la clasa "Wizard" și spune, hei! "Vrăjitor" Vreau să prelungești "Jucătorul".

19:38.900 --> 19:47.990
Deci, va merge la "constructor", și va vedea acest "super" și ce face acest lucru, este nevoie de

19:47.990 --> 19:51.570
noi până la "constructorul" Jucătorului.

19:51.800 --> 20:02.510
Și rulează acest lucru și acum atașează "acest" ca "Wizard" și apoi introduce funcția "nouă" și apoi

20:02.540 --> 20:03.920
adaugă funcția "play".

20:03.920 --> 20:16.550
Acum, dacă mă duc la "vrăjitorul" și spun "joacă", obținem "WEEEEEEE Sunt vindecător", pentru că Shelly este un vindecător.

20:16.760 --> 20:25.800
Dar, de asemenea, am acces la "wizard1.introduce", "Bună, eu sunt Shelly, eu sunt un vindecător".

20:27.220 --> 20:34.580
Și avem, de asemenea, acces la 'wizard2', Uh! Trebuie să mai conduc din nou.

20:34.720 --> 20:35.950
Hai să reluăm asta.

20:38.970 --> 20:42.680
Și nu cred că am copiat al doilea "vrăjitor" ultima oară.

20:42.810 --> 20:47.370
Deci, acum am "wizard2". introduce'.

20:47.380 --> 20:48.780
"Bună Sunt Sean",

20:49.260 --> 20:50.890
"Sunt o magie întunecată".

20:50.920 --> 20:54.480
Această teză nu are sens Sean, dar asta e OK pentru moment.

20:54.970 --> 20:57.250
Să încercăm ceva.

20:57.250 --> 20:58.610
Dacă fac "consola log"

21:01.320 --> 21:02.500
aici.

21:02.740 --> 21:05.520
Și vom spune doar "vrăjitor"

21:08.190 --> 21:11.190
și aici vom spune "jucător", doar pentru a putea face distincția între ei.

21:12.710 --> 21:19.820
Și o să copiez doar primul vrăjitor, astfel încât să nu reușim să ducem două dintre ele, din nou pentru că

21:19.820 --> 21:25.760
noi creăm doi "vrăjitori", o să fugim de două ori. Dar doar pentru sanatatea noastra, vom fugi.

21:25.820 --> 21:32.090
'Shelly'. Deci, voi reîmprospăta și voi adăuga aici. Am uitat să adaug o virgulă

21:35.320 --> 21:43.690
și să refresh, și am o eroare, "Eroare de referință",

21:43.690 --> 21:45.040
"Trebuie să numești un super constructor și o clasă derivată înainte de a accesa" acest ".

21:45.520 --> 21:54.430
Ceea ce spune asta este că, pentru ca eu să accesez "acest" și să obțin "acest tip", trebuie să spun "super" care

21:54.880 --> 21:57.720
rulează funcția "constructor" și "jucător".

21:57.730 --> 21:59.260
Deci asta face "super".

21:59.260 --> 22:05.080
Se pare cam ciudat, dar este doar ceva de care aveți nevoie. O să pun asta în fund după ce sunăm

22:05.080 --> 22:08.830
"super" și acum ar trebui să funcționeze.

22:08.830 --> 22:09.190
Sa vedem

22:14.230 --> 22:18.810
Primul, primul "jucător", "vrăjitor".

22:19.220 --> 22:24.660
Așa că numim "super" imediat ce spunem "un vrăjitor nou", "Shelly, Healer".

22:24.930 --> 22:32.400
Merg la "vrăjitorul" extinde "Jucătorul", conduc funcția "constructor" care spune "super", hei! rulați

22:32.400 --> 22:35.280
funcția "constructor" și "jucătorul" și o conduc.

22:35.400 --> 22:44.570
Iată de ce logăm mai întâi "consola log player" și apoi mergem la wizard-ul "console.log" și apoi executăm

22:44.570 --> 22:46.530
restul clasei.

22:46.550 --> 22:48.180
Foarte tare!.

22:48.390 --> 22:50.730
Acum, doar pentru a vă arăta ceva.

22:50.760 --> 22:57.950
Aceasta este de fapt o sintaxă nouă pe care o veți vedea și o veți "reacționa" și va face parte din ES6.

22:57.960 --> 23:07.090
Dar înapoi în acea zi, așa făceam noi. Codul exact pe care îl am acolo

23:11.630 --> 23:20.060
este chiar aici, se numește moștenire clasică și nu pare prea rău, dar vedeți că există

23:20.520 --> 23:26.250
prototip care este un alt lucru pe care il veti vedea in javascript si sa fiu sincer cu voi,

23:26.250 --> 23:27.000
nu ar trebui să o utilizați cu adevărat.

23:27.000 --> 23:34.320
Nu arata foarte bine si veti vedea ca trebuie sa atasati "jocul" atat "wizard1", cat si "wizard2" si

23:35.650 --> 23:39.210
pur și simplu nu arată la fel de frumos ca asta.

23:39.340 --> 23:41.950
Și odată ce te obișnuiești cu totul.

23:42.160 --> 23:43.820
Nu e prea rău.

23:43.840 --> 23:49.600
Tot ce spunem este că, de îndată ce spunem "clasă", spunem:23:49.600 --> 23:51.060
Hei! probabil vom face o copie a acestui obiect.

23:51.270 --> 23:56.820
Așadar, vrem să facem copii ale jucătorului, vrem să facem copii ale "vrăjitorului" și care se numește "instanțiere".

23:56.820 --> 24:06.020
Când fac cuvântul cheie "nou", spun că fac o instanță de "vrăjitor" și "expert" utilizează unele funcționalități

24:06.020 --> 24:11.270
jucătorul și adaugă și propria sa funcție de "joc".

24:11.270 --> 24:18.770
Sfânt moly, care a fost o mulțime, așa cum am spus, este ceva la care va trebui să vă întoarceți și nu veți

24:18.770 --> 24:19.940
a lua-o imediat.

24:19.940 --> 24:26.380
Este foarte greu să înțelegi pe deplin acest subiect fără a trebui să îl folosiți în viața reală.

24:26.420 --> 24:32.900
Țineți minte acest lucru de fiecare dată când auziți că cineva vorbește despre "tipul de referință" sau "contextul" sau chiar "domeniul de aplicare"

24:33.290 --> 24:35.780
sau "instantierea" ceva.

24:35.840 --> 24:38.790
Ei bine, acestea sunt lucrurile despre care vorbeau.

24:39.020 --> 24:40.980
"Obiectele" sunt cu adevărat complicate.

24:41.000 --> 24:42.570
Sunt foarte greu.

24:42.680 --> 24:47.040
Dar cu asta ne dă o mulțime de putere.

24:47.050 --> 24:51.280
Cu asta, noroc cu exercițiile, te văd în următoarea. Buh-pa.
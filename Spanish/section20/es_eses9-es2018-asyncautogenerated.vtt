WEBVTT

00:00.360 --> 00:00.870
Dar una buena acogida.

00:01.560 --> 00:10.100
Quiero hablarte sobre otras dos nuevas U. S. Características de 2018 y para mostrarle cómo funcionan.

00:10.110 --> 00:18.000
Vamos a usar el ejemplo que teníamos antes en el video sobre las promesas en las que hacemos un bucle a través

00:18.000 --> 00:22.010
de todos estos, ustedes son L's API de Star Wars.

00:22.140 --> 00:30.240
Bueno, obtuvimos los datos y luego solo consolamos lo que recibimos para

00:31.020 --> 00:39.910
que si copio esto y lo pego en nuestra consola, obtenemos a nuestros usuarios.

00:40.060 --> 00:44.820
Tenemos a Luke Skywalker C3 peo r2 d2 y Darth Vader.

00:44.950 --> 00:51.250
Y si esto no le parece familiar, asegúrese de ver primero los videos de promesas antes de

00:51.280 --> 00:52.360
abordar este.

00:52.450 --> 00:59.800
Ahora, la primera característica de la que hablaré que es nueva en Javascript se llama finalmente y, como su

00:59.800 --> 01:03.050
nombre lo indica, nos permite hacer algo.

01:03.070 --> 01:11.820
Finalmente, después de que una promesa ha finalizado y la forma en que funciona, agregamos generalmente al final.

01:12.850 --> 01:22.720
Y este bloque finalmente se llamará independientemente de si el punto funciona o si la promesa se transmite y atrapa

01:22.840 --> 01:24.060
un error.

01:24.130 --> 01:26.310
Así que no importa qué.

01:26.440 --> 01:31.540
Después de que todo se haga dentro de una promesa Finalmente, se le llamará.

01:31.540 --> 01:39.100
Ya sea que resuelva o rechace y haga algo que le indiquemos en nuestro caso, digamos que

01:39.190 --> 01:47.350
puedo tener datos aquí y estos datos solo consolarán el diálogo para ver qué obtenemos y solo diremos extra

01:52.640 --> 01:59.890
para que cuando ejecutemos este más tiempo que voy a copiar vamos a actualizar aquí.

01:59.950 --> 02:08.160
Copiar y pegar, presiono enter, obtenemos más por aquí, pero indefinido.

02:08.160 --> 02:11.490
Y eso es porque finalmente no recibe realmente un parámetro.

02:11.550 --> 02:16.020
Por lo tanto, esto generalmente está vacío, no recibe nada de la promesa.

02:16.380 --> 02:18.690
Entonces podemos dejar esto fuera.

02:19.460 --> 02:25.990
Pero ves aquí que pude llamar extra a pesar de que el punto terminó.

02:26.060 --> 02:35.300
Pero lo que sucede si arrojamos un error y se llama a un bloque catch, podemos simularlo con bastante facilidad.

02:35.970 --> 02:45.280
Podemos hacerlo dentro del punto y luego en JavaScript y arrojar un error diciendo throw Error y lo

02:45.280 --> 02:54.280
que sucederá aquí es que tan pronto como llegue esta línea, arrojará un error, omita todos estos

02:54.280 --> 03:05.500
registros de la consola y golpee el bloque de caché con este parámetro de error, así que si digo esto o copiemos

03:05.500 --> 03:15.180
esto, vamos a actualizar la página, copie y pegue y veamos qué sucede aquí abajo, presionaré enter y veremos

03:15.180 --> 03:24.880
que oh, obtenemos el error, el bloque de caché se ha ejecutado con nuestro error pero también tenemos el

03:24.880 --> 03:28.150
extra llamado que finalmente se llama.

03:28.150 --> 03:36.240
Así que finalmente es genial para esos momentos en los que necesita ejecutar un código sin importar qué.

03:36.340 --> 03:43.870
Después de una promesa, tal vez desee enviar un correo electrónico a un usuario, independientemente de si su solicitud

03:43.870 --> 03:45.590
fue exitosa o fallida.

03:45.850 --> 03:48.530
Tal vez quieras tener un pequeño ícono de notificación.

03:48.550 --> 03:54.100
Finalmente, hay muchas formas de usar y ahora hay una manera de asegurarse de que algo suceda después

03:54.100 --> 03:55.390
de una promesa.

03:55.390 --> 04:04.990
Lo que sea que le digamos ahora, el próximo del que quiero hablar es un poco más avanzado para

04:04.990 --> 04:05.850
explicarlo.

04:05.860 --> 04:19.340
Limpiemos esto y hablemos sobre la función de espera de espera ahora si recuerda que teníamos este código en nuestro video de espera asíncrona y allí

04:19.340 --> 04:29.420
le mostré cómo podemos usar la función de espera asíncrona de sí ocho para hacer nuestro promete una apariencia

04:29.690 --> 04:37.610
más sincrónica en lugar de tener ese cambio prometido de punto, luego DOD, luego DOD

04:37.640 --> 04:48.440
y luego captura de punto, podemos usar async wait ahora, lo bueno de esta nueva característica es que nos permite recorrer

04:48.440 --> 04:57.260
nuestras llamadas async en espera si tenemos múltiples de ellos de la misma manera que podemos usar

04:57.260 --> 05:06.410
el for of, así que usar el for of loop que nos permitió iterar a intervalos, ahora

05:06.410 --> 05:14.060
podemos iterar sobre las promesas de espera que vamos a tener, pero en lugar

05:14.060 --> 05:22.660
de hablar, permíteme mostrarte código ahora digamos que usaremos esto como un ejemplo, vamos a crear

05:22.660 --> 05:32.590
una nueva función y esto se llamará obtener datos para recordar realmente cómo se ve el ciclo for si

05:32.680 --> 05:44.980
tuviera una función, llamémoslo ciclo a través su ls que recibe el parámetro your l y lo hará El bucle que usa el bucle

05:45.190 --> 05:54.640
for dirá que todos ustedes son ls y el que son ls es esta matriz aquí con 3

05:54.640 --> 06:00.140
o más y esto para todos los bucles simplemente

06:00.150 --> 06:13.920
va a un bucle a través de todo y podemos cerrar sesión allí. acerca de pelear, copiar y pegar esto, vamos a actualizar aquí, presione enter y

06:13.920 --> 06:22.380
simplemente haga un bucle a través de su ls ahora y pase a su parámetro else.

06:22.380 --> 06:31.230
Entonces, usando ese conocimiento, ahora podemos crear una nueva función llamada obtener datos para agregar esta nueva función. Haremos exactamente

06:31.230 --> 06:38.870
lo que hace arriba al usar esto para un peso de función, veamos cómo se vería

06:38.870 --> 06:39.550
eso.

06:39.770 --> 06:49.400
Tendremos una función asíncrona para que podamos usar la palabra clave despierto y luego aquí podemos tener una serie de

06:49.940 --> 07:01.240
promesas porque una serie de promesas es irritable y puede ser enlazada por un peso de palabras clave, por lo que estas matrices

07:02.530 --> 07:12.900
de promesas simplemente Se es su mapa de pensamiento Ls que se repetirá y hagamos esto un poco más grande para

07:12.900 --> 07:22.230
que podamos ver que es mejor que vamos a recorrerlo si está bien y va a devolver la búsqueda

07:22.230 --> 07:30.650
de que está bien así y aquí en el primero línea todo lo que estamos haciendo es

07:30.890 --> 07:36.560
crear una serie de estas promesas de búsqueda de cada una

07:40.690 --> 07:50.500
de estas solicitudes, luego podemos usarlas para esperar a recorrer estas promesas, por lo que todo lo que diríamos es

07:51.610 --> 07:55.390
decir una espera y luego aquí digamos

08:00.120 --> 08:08.130
que la gran variedad de promesas de solicitud, que es admirable, recorrerá cada una de estas

08:08.130 --> 08:19.060
promesas cada una de las solicitudes y vamos a extraer esos datos de cada una de las solicitudes diciendo oh espera, solicitud rechazada.

08:19.110 --> 08:25.310
Jason porque recuerda que usamos la palabra clave despierto frente a una promesa.

08:25.450 --> 08:33.820
Y como sabemos, estamos usando la palabra clave wait aquí porque estamos cumpliendo nuestras promesas y

08:33.820 --> 08:36.600
tenemos que esperar la solicitud.

08:36.640 --> 08:41.650
Jason, que de nuevo es una promesa que recibe nuestros datos.

08:41.650 --> 08:49.830
Recuerde similar a como lo hicimos aquí antes y luego simplemente cancelamos nuestro registro, digamos datos para ver mientras conseguimos que

08:49.890 --> 08:55.140
Fi borre esto y simplemente copiemos nuestro nuevo código, hagamos esto un poco

08:58.020 --> 09:03.800
más grande y asegúrese de que no tenga el punto y coma. Lo tengo aqui.

09:03.810 --> 09:07.980
Así que copiemos el archivo o, si no, actualice una página.

09:08.070 --> 09:14.140
Copie sus URL y luego también copiaremos la función y péguela aquí.

09:14.310 --> 09:23.990
Presione enter y despejemos esto y si obtengo datos ahora cuando ejecuto esto, vemos que miramos

09:23.990 --> 09:32.690
que hemos recibido primero los usuarios que están aquí, hagamos esto un poco

09:32.690 --> 09:43.850
más grande para que podamos ver que tenemos el usuarios y la próxima parada tenemos qué tenemos a continuación.

09:43.930 --> 09:52.710
Tenemos las publicaciones, así que cien publicaciones y luego la siguiente parada es el álbum así y esta

09:58.370 --> 10:03.610
es la nueva función Sí 2018, como puede ver aquí.

10:03.650 --> 10:06.200
Es exactamente lo mismo que hicimos anteriormente.

10:06.620 --> 10:11.410
Si ejecuto nuestra función original de obtención de

10:18.390 --> 10:28.360
datos, vemos que obtenemos exactamente los mismos resultados que los álbumes que publicamos que tenemos los usuarios.

10:28.570 --> 10:37.390
Lo único que hace para esperar una característica es que nos permite recorrer estas múltiples promesas casi

10:38.350 --> 10:48.150
como si estuviéramos escribiendo código síncrono correctamente, así que para revisar tenemos finalmente la función que podemos ejecutar al final

10:48.150 --> 10:56.280
de una promesa y nosotros tener un peso de eso toma cada artículo de una serie

10:56.400 --> 11:01.590
de promesas que nos devuelve en el orden correcto.

11:01.590 --> 11:03.890
Todas las respuestas

11:03.980 --> 11:04.400
Todo bien.

11:04.590 --> 11:05.590
Creo que es suficiente.

11:05.610 --> 11:07.990
Es hora de que juegues con esto.

11:08.010 --> 11:09.490
Nos vemos en el próximo video.

11:09.500 --> 11:09.960
Adiós.

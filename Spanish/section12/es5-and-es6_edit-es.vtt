WEBVTT

00:01.650 --> 00:08.220
Si hay algo que hemos aprendido todo este tiempo y este curso es que no hay nada estático

00:08.220 --> 00:10.190
acerca de ser un desarrollador web.

00:10.380 --> 00:19.700
Las mejoras se realizan constantemente en HTML, CSS y Javascript e incluso en los navegadores,

00:19.910 --> 00:21.450
estar constantemente actualizado

00:22.680 --> 00:25.480
Las bibliotecas también se crean constantemente.

00:25.560 --> 00:31.140
Si recuerdas que las bibliotecas son solo piezas de código, podrían ser CSS, podrían ser HTML, podrían

00:31.140 --> 00:36.630
ser Javascript Pedazos de código escritos por otra persona para que podamos usarlo.

00:36.630 --> 00:38.240
Entonces no tenemos que empezar desde cero.

00:40.090 --> 00:43.790
Ahora es la naturaleza humana querer mejorar constantemente.

00:43.890 --> 00:51.200
Y en este video vamos a aprender las nuevas características que todos usarán en 2018.

00:52.190 --> 01:00.310
Pero primero, recapitulamos algo de nuestros videos anteriores. Si recuerda que javascript fue creado por

01:00.310 --> 01:06.600
El navegador Netscape y todos los demás navegadores comenzaron a usar javascript.

01:06.640 --> 01:13.950
Así que Netscape envió javascript a algo llamado ECMA International.

01:14.200 --> 01:20.620
Para que el javascript pueda ser estandarizado y puedan decir, oye, todo el mundo usa esta versión de javascript

01:20.890 --> 01:23.090
en todos los navegadores

01:23.270 --> 01:29.640
Eso es lo que ECMA Script es ECMA Script está bien, es javascript

01:29.690 --> 01:36.590
 Pero es solo la forma estándar de llamarlo para que cuando los navegadores implementen

01:36.590 --> 01:43.670
javascript debería hacer y cómo leen javascript Bueno, todos están de acuerdo con el estándar.

01:43.680 --> 01:52.390
Ahora, cada vez que veas algo así como ES6 y verás mucho, ES6 simplemente se para

01:52.390 --> 01:59.150
para la versión 6 de ECMAscript.

01:59.200 --> 02:08.500
Así que sí, estaba la versión 1 de Ecmascript durante todo el año y actualmente estamos en la versión 7, pero

02:08.740 --> 02:13.470
todavía es nuevo, así que solo estamos aprendiendo la versión 5 y la versión 6 por ahora.

02:13.870 --> 02:21.040
Pero la versión 5 y la versión 6 presentan algunas características nuevas que son realmente realmente potentes y hacen que la codificación

02:21.040 --> 02:23.190
en javascript realmente muy bueno.

02:23.380 --> 02:29.090
Y la mayoría de las bases de códigos que verá en 2018 usarán estas características.

02:29.530 --> 02:36.370
Es un tema muy emocionante para mí, es una de mis partes favoritas de javascript ahora y estoy emocionado

02:36.370 --> 02:42.350
para mostrarte algunas de estas nuevas características que harán tu vida mucho más fácil.

02:42.370 --> 02:48.640
Ahora bien, una cosa que tal vez estés pensando es, ¡Ah! Andre:no quiero aprender algo si los navegadores no lo hacen

02:48.640 --> 02:51.350
apóyalos y no puedo usarlos.

02:51.880 --> 02:54.170
Pero Uh! no te preocupes mi amigo

02:54.250 --> 02:58.950
Estas son todas las características que son compatibles, ¿sabes por qué?

02:59.330 --> 03:03.080
Bueno, principalmente por algo llamado BABEL.

03:03.340 --> 03:10.120
Hace unos años, el programador creó BABEL para que los desarrolladores puedan comenzar a usar las nuevas funciones de JavaScript

03:10.780 --> 03:11.650
como vienen

03:11.650 --> 03:18.130
Recuerde que ECMAScript lanza versiones todo el tiempo, ahora sin tener que esperar a que los navegadores implementen

03:18.130 --> 03:19.330
estas características.

03:19.330 --> 03:24.440
BABEL, nos permitió, bien usarlos de inmediato.

03:24.510 --> 03:26.330
¿Ahora cómo lo hacen?

03:26.340 --> 03:28.120
Echemos un vistazo,

03:28.160 --> 03:37.140
Si voy a probarlo aquí, verás que BABEL me muestra algo que puedo escribir, y aprenderé

03:37.140 --> 03:42.720
la sintaxis lo suficientemente pronto no se preocupe, no puedo escribir algo como esto, que es la nueva forma de escribir

03:42.720 --> 03:50.550
javascript con ECMAScript 6 y se compila en esto.

03:50.550 --> 03:51.750
Ahora qué significa eso.

03:51.750 --> 04:00.630
Significa que lee un archivo línea por línea y luego lo cambia a una versión de javascript que todos los navegadores

04:00.630 --> 04:03.480
saber y funciona en todos los navegadores.

04:03.480 --> 04:10.650
Cuando implementamos nuestra aplicación o sitio web, lo que significa ponerlo en línea después de que hayamos terminado,

04:10.650 --> 04:18.780
podemos usar BABEL para decir que oye nuestro archivo javascript y transformarlo en esto, por lo que funciona en

04:18.780 --> 04:20.410
todos los navegadores

04:20.520 --> 04:26.670
Entonces, sin siquiera pensarlo, puedes escribir

04:26.670 --> 04:26.790
todo tu código de la forma más nueva y mejor para escribirlo.

04:26.790 --> 04:34.470
Puedes ver cuán limpio es esto y BABEL se encargará de cambiar todo para ti

04:34.470 --> 04:35.480
para que los navegadores puedan leerlo.

04:36.560 --> 04:38.400
¿No es asombroso? Suficiente de eso.

04:38.420 --> 04:40.280
Aprendamos algunas sintaxis nuevas

04:40.430 --> 04:41.320
Y no tengas miedo

04:41.330 --> 04:48.410
ES5 y ES6 hicieron que JavaScript fuera mucho más fácil y divertido de escribir. A partir de ahora tomaremos lo que

04:48.410 --> 04:54.140
En este video aprendemos a escribir todo nuestro código porque es lo que la industria está utilizando en este momento.

04:54.170 --> 04:57.320
Y esta es la razón por la cual se te preguntará durante las entrevistas.

04:57.320 --> 04:59.200
Entonces empecemos.

05:04.760 --> 05:09.850
La primera característica que voy a mostrar es 'let' y 'const'.

05:10.020 --> 05:13.500
Estos son en realidad muy, muy simples.

05:13.530 --> 05:17.090
Estas son nuevas formas de declarar variables.

05:17.220 --> 05:25.230
Entonces, si ven por acá en nuestra sección fuera de línea, verán que las variables javascript tienen ahora, dos nuevas formas

05:25.380 --> 05:33.370
de declarar una variable, y como una variable de hecho que hemos estado usando hasta este punto, no lo hacemos

05:33.370 --> 05:35.010
Realmente necesito usarlo otra vez.

05:36.080 --> 05:40.530
Ahora tenemos algo llamado 'let', para mostrarle cómo funcionan ambos.

05:40.790 --> 05:42.340
Hagamos un pequeño ejemplo.

05:42.350 --> 05:53.970
Voy a decir 'const player' y 'const' significa constante, dirá 'bobby' y dirá

05:54.170 --> 05:59.420
'deje que la experiencia sea igual a cien' y dirá

05:59.830 --> 06:15.260
'let wizardLevel igual a false'. Ahora si hago algo, como 'si la experiencia es mayor que 90 entonces

06:18.630 --> 06:21.850
(let wizardLevel) es igual a true '.

06:21.980 --> 06:26.500
OK, entonces estas parecen variables. Nada es diferente.

06:26.650 --> 06:30.010
Vamos a ejecutar esto a través de la consola y ver qué pasa.

06:31.450 --> 06:32.020
DE ACUERDO.

06:32.080 --> 06:34.000
Si ahora miro 'wizardLevel', obtengo 'false'

06:39.820 --> 06:46.510
Hmmm! eso es extraño, porque en el video anterior donde hablamos sobre el alcance de

06:46.510 --> 06:51.430
tenía 'wizardLevel' tiene una variable, me gustaría haber 'verdadero' aquí.

06:51.470 --> 06:59.450
Entonces, si esto fuera una variable y esto fuera variable, 'wizardLevel' en lugar de 'falso' será 'verdadero'.

06:59.590 --> 07:02.810
Ahora eso es confuso.

07:02.810 --> 07:05.860
Eso es porque no está dentro de una función.

07:05.870 --> 07:13.430
Esto es un poco complicado pero con la variable solo pudimos crear un alcance, dentro de una función,

07:13.880 --> 07:16.720
pero nunca si tuviera llaves.

07:16.790 --> 07:22.110
Pero dentro de 'si'.

07:22.290 --> 07:27.230
Con 'let', cuando digo 'let' y 'let', bueno,

07:27.420 --> 07:37.230
ahora he creado una variable 'wizardLevel' dentro de 'if', así que la única forma de que pueda acceder a esto es dentro de

07:37.230 --> 07:38.430
el si'.

07:38.430 --> 07:42.220
Si hago 'console.log (wizardLevel)' aquí

07:44.930 --> 07:53.880
y 'console.log (wizardLevel)' afuera y luego vamos a poner 'inside'

07:56.350 --> 08:08.430
y 'afuera'. Si copio esto, lo pego, 'adentro', obtengo 'verdadero', 'afuera',

08:08.680 --> 08:17.890
Me sale 'falso', porque ahora con 'dejar', cada vez que está envuelto en un corchete, bueno, crea un nuevo

08:18.130 --> 08:21.610
alcance, versus con una variable,

08:22.000 --> 08:23.500
si cambio esto a una variable (var)

08:27.420 --> 08:29.910
y copio esto de nuevo y actualizo,

08:32.970 --> 08:46.010
si copio esto, obtengo 'inside', igual a 'true' y 'outside' es igual a 'true', porque 'wizardLevel' ya tiene

08:46.010 --> 08:46.660
sido cambiado

08:46.730 --> 08:55.550
No se crea ningún ámbito nuevo, dentro de las llaves, porque esta no es una función.

08:55.550 --> 08:56.940
Ahora sé que es realmente muy confuso.

08:56.960 --> 09:03.690
Pero la única gran conclusión de esto es, simplemente no use la variable (var) nunca más. variables (var) es realmente bastante confuso.

09:03.710 --> 09:08.870
Ahora piense en 'dejar' como la nueva variable.

09:08.960 --> 09:14.980
Entonces, de ahora en adelante, vamos a usar 'let' para las variables, pero ¿qué es 'const'?

09:15.380 --> 09:19.130
Bien 'const' es aún más genial.

09:19.220 --> 09:20.240
Ver este.

09:20.570 --> 09:28.720
Si deseo cambiar el nivel de experiencia, puedo decir que "la experiencia es igual a 80".

09:28.930 --> 09:31.040
Y ahora si miro 'experiencia',

09:31.300 --> 09:32.940
Bueno, la "experiencia" es igual a 80.

09:32.980 --> 09:44.050
Pero si quiero cambiar el jugador 'Bobby' a un nuevo nombre, igual a 'Sally', me sale un error,

09:44.050 --> 09:44.960
'Asignación a variable constante'.

09:44.960 --> 09:47.040
Lo que eso significa es, como una constante,

09:47.070 --> 09:54.870
no puedes reasignar a la variable. Entonces no puede ser actualizado.

09:54.870 --> 09:56.820
Ahora, ¿por qué sería útil?

09:56.820 --> 10:02.820
Es realmente útil porque ocurren muchos errores cuando trabajas en un equipo de personas.

10:02.910 --> 10:07.920
Si tiene algo así como 'jugador' y alguien cambia el nombre del jugador mientras está trabajando en

10:07.920 --> 10:13.200
un programa y todavía piensas que es 'Bobby' y sigues recibiendo errores

10:13.200 --> 10:13.510
porque alguien más lo ha tocado

10:13.620 --> 10:15.970
Bueno, eso es un problema, ¿no?

10:15.990 --> 10:23.930
Pero usando 'const', asegúrate de que esta variable de jugador siempre tendrá el mismo valor.

10:23.970 --> 10:30.960
Así que esto es realmente muy útil y mi recomendación es que si tienes algo que no es

10:30.960 --> 10:33.630
cambiarlo debería ser una constante.

10:33.720 --> 10:43.740
Entonces una función podría ser una constante porque bien si esta función o si la asignación de 'a' no va

10:43.740 --> 10:51.990
para cambiar, entonces nos sentimos mucho más seguros usando 'const' que digamos 'let' porque nos aseguramos de que nadie

10:51.990 --> 10:56.000
asigna algo más a 'a'.

10:56.080 --> 11:00.110
Entonces la regla a partir de ahora es usar 'const',

11:00.370 --> 11:07.060
Si usa una variable que no cambia, la mayoría de las veces la usará y estará usando una variable

11:07.060 --> 11:12.720
muere tu reasignar algo para que te guste el nivel del asistente donde cambia de 'verdadero' a 'falso'

11:12.730 --> 11:13.470
'falso' a 'verdadero'.

11:13.810 --> 11:16.470
Bueno, entonces usa 'let'.

11:16.690 --> 11:28.490
Una cosa con 'const' que debes tener en cuenta es que si haces un objeto 'const' (obj) es igual a 'player'

11:29.950 --> 11:37.760
'bobby', 'experiencia', 'uno cazado' y

11:37.970 --> 11:39.220
'WizardLevel' a 'falso'.

11:39.410 --> 11:50.470
Bueno, si copio este objeto e intento reasignar este objeto para decir un número, me sale un error porque

11:50.470 --> 11:51.610
es una constante.

11:51.610 --> 11:55.780
¡Pero! si intento y cambio una propiedad

12:00.060 --> 12:04.750
ahora mi 'wizardLevel' es 'verdadero'.

12:04.750 --> 12:15.370
Una cosa con constante es que puedes cambiar las propiedades de los objetos,

12:16.860 --> 12:18.480
todavía no puedes reasignar la variable.

12:18.520 --> 12:20.520
Muy bien a cosas más divertidas.

12:23.310 --> 12:26.410
Hagamos Destructuring.

12:26.950 --> 12:30.510
Y este voy a mostrar que harás tu vida mucho más fácil.

12:32.050 --> 12:41.780
De nuevo, si realmente tenemos nuestro 'objeto (obj)' aquí, digamos que queríamos agarrar estos objetos, entonces tendremos

12:41.780 --> 12:49.460
hacer 'const jugador es igual a object (obj) .player' hará,

12:49.470 --> 13:03.590
'la experiencia const es igual a object (obj) .experience' y luego a 'let wizardLevel'

13:03.980 --> 13:05.620
es igual a 'objeto (obj) .wizardLevel'.

13:05.870 --> 13:08.710
Y fue una gran cantidad de tipeo para acceder a estas propiedades.

13:08.750 --> 13:18.530
Bueno, con la desestructuración, puedes hacer esto, puedes decir 'const player' y 'experience'

13:21.890 --> 13:23.560
del objeto.

13:23.570 --> 13:31.970
Entonces, con esta sintaxis, hace exactamente lo mismo que las dos primeras líneas aquí, simplemente selecciona el

13:31.970 --> 13:35.440
propiedades que desea de un objeto.

13:35.690 --> 13:45.290
Y ahora tienes 'const' 'player' y 'experience' a tu disposición para que puedas usar 'player' en cualquier lugar que quieras

13:45.290 --> 13:56.520
en su base de código y luego para 'dejar' que podemos hacer 'wizardLevel' es igual a 'object (obj)', mucho más limpio.

13:56.570 --> 14:00.500
Solo tienes que acostumbrarte, pero es mucho más agradable mirarlo.

14:00.510 --> 14:09.370
Está bien otra cosa genial que puedes hacer con los objetos. 'const' name es igual a 'john snow'.

14:10.680 --> 14:26.600
Podemos comenzar un nuevo objeto aquí y podemos decir ahora que 'nombre' es 'hola'

14:26.730 --> 14:27.980
y podemos hacer 'rayo', 'smith'

14:28.110 --> 14:29.600
'hihi'.

14:29.770 --> 14:30.000
Todo bien.

14:30.010 --> 14:36.730
Así que este es un objeto tonto, pero quería mostrarte algunas formas nuevas de declarar propiedades del objeto

14:41.320 --> 14:42.280
Ahora, en ES6 puedes tener,

14:42.320 --> 14:50.980
en lugar de la antigua forma de tener solo 'jugador' o 'experiencia' o 'wizardLevel'

14:51.250 --> 15:00.160
podemos tener algo dinámico que podamos asignar como 'john snow' o podemos hacer 'ray' más 'smith' o podemos

15:00.160 --> 15:07.450
hacer 'uno' más 'dos' y tener estos valores de propiedad dinámicos.

15:07.450 --> 15:11.660
Déjame mostrarte cómo funcionan.

15:11.960 --> 15:16.240
Si accedo a object (obj) ahora, tengo tres iguales.

15:16.240 --> 15:16.660
'hihi'.

15:16.670 --> 15:18.040
Y 'john snow' es igual a 'hola'

15:18.080 --> 15:25.400
Nuevamente nuevas formas de declarar propiedades, muy útil si necesita calcular algo para el

15:25.400 --> 15:26.530
El valor de la propiedad.

15:27.290 --> 15:34.630
Pero incluso más genial es poder hacer algo como esto.

15:34.640 --> 15:37.210
Imagina que tienes un

15:37.250 --> 15:38.620
'const a' es igual a

15:38.670 --> 15:39.390
'simon'

15:43.450 --> 15:46.560
'const b' es igual a 'verdadero'.

15:47.890 --> 15:52.920
Y 'const c' es un objeto vacío.

15:53.130 --> 16:06.540
Y si quisiéramos agregar esto a un objeto, tendríamos que hacer 'a' es a, 'b' es b y 'c' es c, y algunas veces

16:06.540 --> 16:09.820
querías que la propiedad coincidiera con el valor.

16:09.820 --> 16:12.150
Nuevamente con el nuevo javascript.

16:12.150 --> 16:23.760
Si la propiedad y el valor son los mismos en ese caso, podemos decir simplemente a, b, c para que podamos eliminar, podemos eliminar el

16:23.760 --> 16:29.700
declaración que tenemos con propiedad y valor si son iguales y solo mantenlo así.

16:29.700 --> 16:34.330
Una vez más, esto es algo que cuando lleguemos a la sección de Riact va a ser muy útil.

16:35.450 --> 16:45.950
Muy bien, algo aún más divertido y esta vez su plantilla se encarga de 'Cadenas de plantillas'.

16:46.060 --> 16:52.030
Ahora recuerde cuando tenemos, digamos un saludo, cuán molesto fue que tuvimos que hacer.

16:52.120 --> 16:53.050
"Hola "

16:55.580 --> 16:56.590
'nombre'

16:56.690 --> 17:09.520
más 'parece que está haciendo' más 'saludo' y luego dice que tenía un signo de exclamación y también tenía que

17:09.520 --> 17:12.460
Preocuparse por la barra diagonal inversa si tuviera un apóstrofo.

17:12.460 --> 17:15.550
Eso fue realmente tedioso y molesto.

17:15.550 --> 17:20.460
Ahora, si supieras algo realmente divertido, en lugar de hacerlo de esta manera.

17:22.500 --> 17:24.930
Puedes tener 'greetingBest'

17:24.950 --> 17:30.800
equivale a algo llamado cadenas de plantillas y estas son marcas de retroceso.

17:31.020 --> 17:34.270
Por lo tanto, la parte de atrás de esto está justo encima de su tecla Tab.

17:34.290 --> 17:43.650
Si utiliza una Mac en lugar de utilizar comillas dobles o comillas simples, esto significa cadenas de plantillas y ahora

17:43.680 --> 17:50.920
puede usar comillas dobles o comillas simples en cualquier lugar que desee y será una cadena.

17:51.420 --> 18:02.020
Pero incluso más genial si tienes 'nombre' es igual a "Sally" y 'edad' es igual a "34".

18:02.060 --> 18:06.350
'mascota' es "caballo".

18:06.390 --> 18:07.550
Ahora podemos hacer,

18:07.560 --> 18:08.250
'Hola'

18:10.980 --> 18:12.050
'nombre'

18:12.240 --> 18:18.430
'pareces ser', fíjate en la sintaxis y el colorido.

18:18.430 --> 18:20.920
'edad' menos 10

18:23.750 --> 18:25.520
'Qué adorable' mascota ($ mascota)

18:27.780 --> 18:29.310
'tienes'

18:32.570 --> 18:34.240
así que note lo que hicimos aquí.

18:34.450 --> 18:39.350
Voy a copiar esto para que lo tengamos, cuando lo comento.

18:39.380 --> 18:43.880
Ahora si miro en la consola, actualizaré.

18:43.880 --> 18:53.390
Ya ves eso ahora en lugar de hacer todas esas comillas dobles y más, y te preocupas por el espaciado dentro de estas marcas de retroceso,

18:53.420 --> 19:02.360
Puedo decir un trozo de cuerda y luego agregar dinámicamente usando el signo de dólar y luego el

19:02.360 --> 19:05.220
las llaves son un valor que queremos.

19:05.400 --> 19:08.640
Nuevamente podemos hacer cualquier tipo de expresión.

19:08.640 --> 19:10.560
Entonces 'edad' menos 10.

19:10.560 --> 19:12.070
'Qué linda mascota ($ mascota) tienes'

19:12.090 --> 19:13.620
Veamos qué pasa, si lo hago,

19:13.620 --> 19:17.470
'saludo mejor'. Mira eso,

19:17.690 --> 19:18.460
"Hola Sally.

19:18.470 --> 19:20.570
Usted parece tener 24 ".

19:20.720 --> 19:22.590
"Qué caballo tan encantador tienes".

19:23.720 --> 19:24.430
Muy genial.

19:24.470 --> 19:29.060
Por lo tanto, esto es muy, muy útil. Definitivamente lo usaré, tarde en el curso.

19:30.150 --> 19:38.440
Otra cosa que quiero mostrarte es 'argumentos predeterminados', que pueden hacer algo como 'saludar', diremos 'nombre'

19:38.450 --> 19:46.790
es igual a la cadena vacía, 'edad' equivale a '30' y diremos.

19:46.800 --> 19:51.760
'mascota' es un "gato".

19:52.130 --> 19:54.450
Copiemos lo que teníamos antes.

19:55.520 --> 19:58.880
Con el saludo, voy a comentar esto

20:01.810 --> 20:03.410
y devolverá esto.

20:03.790 --> 20:05.790
Entonces nada ha cambiado.

20:05.800 --> 20:08.570
Solo tenemos una función que devuelve un saludo.

20:09.590 --> 20:14.740
Lo único nuevo es esto, déjame mostrarte lo que hace.

20:15.700 --> 20:26.210
Si comento esto, copio esto y lo coloco en la consola, y ahora ejecuto 'saludar', 'Hola, parece que tienes 20 años'.

20:26.230 --> 20:27.870
"Qué gato tan adorable tienes".

20:29.560 --> 20:35.470
¿Lo entendiste, a pesar de nuestro navegador, y permitíteme actualizar, para que estés seguro de que nuestro navegador tiene

20:35.470 --> 20:39.150
ni idea de qué edad o mascota es.

20:39.250 --> 20:41.800
Pero, si ejecuto esta función

20:46.250 --> 20:53.870
debido a la forma en que hice los parámetros, les di argumentos predeterminados que dicen si, no proporciono

20:53.870 --> 20:58.640
un valor para el nombre que no tengo, no he dado ningún argumento.

20:58.910 --> 20:59.810
Bien, entonces hazlo.

20:59.810 --> 21:14.490
'nombre' cadena vacía, haga 'edad' '30' y haga 'mascota', 'gato', si lo hace ahora, 'saluda', 'Juan', '50' y haremos "mono".

21:14.490 --> 21:15.260
Ahora entiendo,

21:15.270 --> 21:16.940
"Hola John, pareces tener 40 años".

21:16.950 --> 21:24.990
"Qué mono tan encantador tienes". Esto se ignora porque le pasé los parámetros, pero de lo contrario puedo pasar

21:24.990 --> 21:31.410
un parámetro predeterminado para que cuando alguien llama a esta función y no proporcionan estos argumentos

21:32.640 --> 21:38.210
mi función no fallará porque tengo buenos argumentos por defecto.

21:38.410 --> 21:39.610
Muy genial.

21:39.680 --> 21:40.000
Todo bien.

21:40.010 --> 21:42.060
Qué más tenemos.

21:42.500 --> 21:50.880
Refresquemos aquí, si recuerda que teníamos un tipo más para hacer 'TIPOS DE JAVASCRIPT' y eso es un 'Símbolo'.

21:50.900 --> 21:56.720
En realidad, no se usa muy a menudo, pero quería mostrarte porque, aunque es un tipo de, queremos

21:56.720 --> 22:09.000
complete los siete tipos de javascript, y un símbolo es especial porque si tengo el símbolo uno (sym1), creo un símbolo

22:09.000 --> 22:18.600
haciendo este índice y podría tener un segundo símbolo (sym2) que es 'símbolo ()'.

22:18.760 --> 22:32.110
Y dentro de aquí podemos poner cualquier cosa, podemos poner 'foo' y el símbolo variable (var) 3 (sym3) es igual a 'Símbolo ()' y lo haremos

22:32.110 --> 22:34.490
di 'foo' también.

22:34.540 --> 22:37.540
Lo que es tan único sobre los símbolos,

22:37.870 --> 22:40.310
¡Oh! deberíamos usar 'dejar' aquí.

22:41.560 --> 22:54.580
Si copio esto y accedo a "sym1", obtengo "symbol ()" accediendo a "sym2", obtengo "foo", y "sym3" obtengo "foo".

22:54.790 --> 23:05.240
Pero lo único es que si hago 'sym2' es igual a 'sym3', obtengo falso.

23:05.290 --> 23:12.430
A pesar de que, parece que son exactamente lo mismo, y se usan símbolos porque crean

23:12.430 --> 23:20.630
este tipo completamente único. Para que pueda asegurarse de que nunca va a haber ningún conflicto.

23:20.740 --> 23:26.410
Y el valor del símbolo se usa como un identificador principalmente para las propiedades del objeto.

23:26.410 --> 23:32.080
Es prácticamente el único propósito de eso porque a veces no quieres las propiedades del objeto si

23:32.080 --> 23:37.660
tienen miles de ellos para colisionar y ser los mismos porque entonces obtendrán errores.

23:37.780 --> 23:42.550
No lo veremos demasiado y, por supuesto, no lo verás en la naturaleza demasiado, pero quería mostrar

23:42.550 --> 23:48.820
lo haces independientemente porque si bien queremos saber todos los tipos de JavaScript.

23:48.930 --> 23:49.470
Todo bien.

23:49.590 --> 23:55.980
Una última, sé que hemos cubierto mucho, pero esta es la mejor y eso es "funciones de flecha".

23:57.910 --> 24:09.140
Hasta este punto, si queríamos hacer algo como agregar, teníamos que hacer 'a', 'b' y 'devolver a' más 'b'.

24:09.700 --> 24:17.500
Y es posible que se haya cansado de escribir funciones una y otra vez.

24:17.660 --> 24:19.330
Bueno, ahora tienes funciones de flecha.

24:19.370 --> 24:21.590
Entonces, con una función de flecha que puedes hacer, mira eso,

24:32.020 --> 24:35.090
así que cada vez que veas esta sintaxis

24:35.220 --> 24:37.530
Oop! y tuve que pasar 'a' y 'b' aquí también,

24:37.540 --> 24:44.440
cada vez que veas esta sintaxis es lo mismo que decir función, pero ahora es solo la forma abreviada

24:44.440 --> 24:47.180
para que no tenga que escribir constantemente la función.

24:47.410 --> 24:56.680
Y la belleza de esto, es que podrías haber hecho 'return a' y 'b' y eso funciona completamente.

24:56.680 --> 25:04.180
Entonces la única diferencia es que tenemos una expresión de función que acepta un parámetro y tenemos esto

25:04.180 --> 25:08.620
flecha de grasa, pero con una función de flecha.

25:08.990 --> 25:11.240
Si tiene una sola devolución,

25:13.870 --> 25:18.100
Bueno, puedes ponerlo en una línea, y asume que quieres devolver esto.

25:18.190 --> 25:27.440
Si guardo esto y lo copio aquí, ¡oop! No necesito esta sintaxis

25:27.560 --> 25:33.530
Vamos a copiar eso una vez más 'agregar 4 y 2'.

25:33.700 --> 25:37.060
Esa es la primera función y luego la nueva forma con la función de flecha.

25:37.080 --> 25:41.440
'add2', '4' '2'.

25:41.680 --> 25:43.060
Nuevamente obtengo lo mismo.

25:43.060 --> 25:48.240
Vuelve automáticamente porque todo, bueno, está en una línea.

25:48.250 --> 25:51.900
Se ve muy, muy agradable, mucho más fácil de escribir que el anterior.

25:53.220 --> 25:55.360
Y ahí lo tienes.

25:55.620 --> 25:58.370
Sé que fue mucha información.

25:58.380 --> 26:04.380
Asegúrate de hacer los ejercicios después de este video para familiarizarte con la sintaxis,

26:04.380 --> 26:05.770
son solo nuevas formas de hacer las cosas.

26:05.790 --> 26:10.480
Estos le ayudarán a escribir un código mejor y más limpio.

26:11.330 --> 26:19.050
Y solo para mostrarle lo que hemos cubierto, bueno, ha logrado terminar todo y el perfil de la sección.

26:20.090 --> 26:25.530
Desde variables a condicionales, hasta finalmente la función de flecha.

26:25.610 --> 26:30.760
Cubrimos todo lo que queríamos para javascript y seguir adelante.

26:30.890 --> 26:37.600
Vamos a usar estas nuevas sintaxis para escribir nuestro código.

26:37.610 --> 26:40.430
Espero que estés emocionado ya que empiezo a usar estos.

26:40.670 --> 26:42.630
Te veré en el próximo.
A-Dios.
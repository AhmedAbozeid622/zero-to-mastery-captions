WEBVTT

00:01.850 --> 00:03.660
Tipo coerción.

00:03.890 --> 00:09.940
Si hay una cosa que te hará arrancarte el pelo por la frustración.

00:10.150 --> 00:19.290
Es cauteloso si escribe el origen de Google en JavaScript y mira algunas de las publicaciones, verá a mucha gente enojada por

00:19.290 --> 00:26.310
algunas de las cosas funky que hace JavaScript y vamos a hablar de eso y estoy solo

00:26.310 --> 00:32.700
te daré una breve descripción del mismo porque se vuelve realmente complejo y es algo

00:32.730 --> 00:39.390
que debes entender y saber de qué se trata, pero no tienes que conocer todos los

00:39.510 --> 00:43.630
detalles debido a la mayoría de las partes difíciles.

00:43.680 --> 00:48.060
Bueno, no deberías usarlo en tu código porque es confuso.

00:48.060 --> 00:50.500
Entonces, ¿qué es la causa tipo?

00:51.620 --> 00:59.620
Es algo como esto equivale a dos cuerdas uno y eso equivale a dos.

00:59.690 --> 01:08.000
Es cierto que la precaución de tipo significa que cuando la apariencia que son las cosas a la izquierda

01:08.510 --> 01:13.070
y a la derecha del operador son de diferentes tipos.

01:13.120 --> 01:22.150
Ese no es el tipo de cadena final, uno de ellos se convertirá en un valor equivalente por el motor de JavaScript.

01:22.990 --> 01:27.740
Entonces el motor de JavaScript va a decir que 1 es igual a la cadena 1.

01:27.940 --> 01:29.890
Creo que te refieres al número uno.

01:29.890 --> 01:39.550
Así que va a hacer esto por nosotros y comparar el número uno con el número uno ahora basado en la

01:39.640 --> 01:47.100
precaución del tipo de definición significa que el lenguaje convierte un cierto tipo a otro tipo.

01:47.150 --> 01:55.460
Déjame hacerte una pregunta, ¿todos los idiomas tienen precaución de tipo?

01:55.490 --> 01:58.900
¿Qué crees que sí que hacen?

01:59.470 --> 02:07.230
Porque siempre necesitamos convertir tipos entre programas para hacer cosas en la memoria.

02:07.290 --> 02:12.240
Los diferentes tipos se ven completamente diferentes de lo que escribimos.

02:12.250 --> 02:16.290
Escribe el número cinco en la memoria física real.

02:16.290 --> 02:23.070
Oh, mi computadora está representada una vez en cero y todos los idiomas hacen esto.

02:23.070 --> 02:29.110
Por lo tanto, hay algún tipo de precaución de tipo en diferentes niveles de la pila.

02:29.430 --> 02:37.650
Sucede que JavaScript tiene una causa de tipo especialmente pesada en la naturaleza porque es de tipo

02:37.650 --> 02:40.460
dinámico, por eso lo hace.

02:40.500 --> 02:50.170
Volvamos al ejemplo en JavaScript, la precaución de tipo ocurre cuando usa el signo doble igual doble igual

02:50.170 --> 02:59.410
simplemente significa comparar los dos valores y si tienen tipos diferentes, intente forzar uno al mismo

02:59.920 --> 03:00.790
tipo.

03:02.330 --> 03:13.880
Si volvemos y hacemos una cadena aquí y hago tres iguales y corro me sale falso porque tres iguales en

03:13.940 --> 03:17.180
JavaScript significa comparar con valores.

03:17.360 --> 03:25.300
Pero no intentes maldecir los valores de manera explícita con tu comparación y haz exactamente lo que te digo.

03:25.470 --> 03:32.000
Entonces, ¿alguna vez hay que usar dos iguales en lugar de tres iguales?

03:32.160 --> 03:33.340
Mm hmm.

03:33.510 --> 03:34.410
Yo diré eso

03:34.410 --> 03:35.970
No, no lo hay.

03:36.000 --> 03:43.930
Algunas personas pueden argumentar que el doble igual en realidad puede tener algunas aplicaciones interesantes en las que

03:44.010 --> 03:51.890
coaccionamos algo y hacemos algún tipo de verificación muy rápido, pero no es un código predecible correcto.

03:51.900 --> 03:53.000
Puede ser confuso.

03:53.040 --> 04:00.100
Realmente podría ser una trampa y engañar a algunas personas, así que siempre use tres iguales en lugar de dos.

04:00.300 --> 04:04.590
Ahora escriba precaución no sucede solo con el signo igual.

04:04.590 --> 04:06.870
También puede hacer una declaración if.

04:07.020 --> 04:19.930
Entonces, si uno devuelve cinco y si ejecuto esto bien, no hay ninguna función aquí para consolar.

04:21.030 --> 04:22.900
He estado grabando durante un largo día hoy.

04:22.910 --> 04:24.560
Así que denme un descanso a todos.

04:24.640 --> 04:25.360
Todo bien.

04:25.530 --> 04:29.540
Si ejecuto este cinco se registra.

04:29.580 --> 04:30.450
Porqué es eso.

04:30.480 --> 04:35.400
Porque el curso javascript es igual a verdadero.

04:35.490 --> 04:36.930
¿Qué pasa si hago cero aquí?

04:36.990 --> 04:44.220
Si hago cero, ningún curso de JavaScript es esto y dice bien, quiero booleano aquí.

04:44.430 --> 04:53.050
Así que voy a tomar su cero y convertirlo en falso ahora, este tipo de precaución

04:53.050 --> 04:55.390
tiene muchos detalles interesantes.

04:56.260 --> 05:02.470
Y, de hecho, hay un pequeño y agradable sitio web que muestra algunas de las comparaciones

05:02.470 --> 05:04.990
que JavaScript hace con tres iguales.

05:04.990 --> 05:08.920
Sin precaución, las cosas tienen sentido.

05:08.920 --> 05:13.860
Ves que falso es igual a dos falsos y eso es todo.

05:13.910 --> 05:23.070
Puede ver que string false solo es triple igual y devuelve true con string false nuevamente.

05:23.540 --> 05:26.740
Pero si hacemos doble igual bien.

05:27.440 --> 05:27.810
Oh chico.

05:27.830 --> 05:30.790
Eso es un desastre, ¿no?

05:30.800 --> 05:41.210
Por ejemplo, la cadena uno es lo mismo que verdadero, una matriz que contiene uno también es verdadera cuando se compara con la

05:41.210 --> 05:42.880
cadena de uno.

05:43.100 --> 05:47.200
Y hay tantos casos extraños y pequeños aquí.

05:47.390 --> 05:49.820
Si quieres jugar con esto, adelante.

05:49.820 --> 05:53.330
Pero me gustaría seguir con triples iguales.

05:53.360 --> 06:03.260
También puede ver algunas de las declaraciones if aquí y algunos de los casos F que realmente pueden ser difíciles ahora si vamos a esta

06:03.380 --> 06:10.550
página MDMA a la que vincularé en este video, vemos que tenemos el doble es igual al

06:11.090 --> 06:12.410
triple es igual.

06:12.500 --> 06:20.270
Pero también algo llamado Object dot es bastante nuevo en JavaScript y es interesante y probablemente

06:20.270 --> 06:23.380
no lo veas muy a menudo.

06:23.390 --> 06:24.790
Pero creo que es interesante.

06:24.800 --> 06:31.730
Así que vamos a hablar sobre eso rápidamente, como ve en JavaScript, hay un concepto de

06:32.360 --> 06:35.120
cero negativo y más cero.

06:35.120 --> 06:35.850
Extraño lo sé.

06:36.200 --> 06:48.850
Entonces, si hago cero cero triple igual más cero y ejecuto, me vuelvo verdadero, pero son cosas técnicamente diferentes en JavaScript, por

06:49.030 --> 06:55.180
lo que realmente puedo hacer el punto del objeto y,

06:59.190 --> 07:04.190
dados los dos parámetros, ejecutar y obtener falso.

07:04.400 --> 07:12.910
Ahora, ¿por qué es esto útil si volvemos a esta página y vemos que el objeto que funciona es prácticamente igual

07:12.940 --> 07:16.300
al triple igual, excepto en algunos casos?

07:16.420 --> 07:19.220
Ese es el 0 positivo y negativo.

07:19.390 --> 07:29.790
Y si nos desplazamos hasta este pequeño y funky y no un no y podemos hacer un curso completo sobre lo extraño que

07:29.790 --> 07:39.360
es, no es un número, pero si no hice un número que no está en números en JavaScript y hago triple no

07:39.700 --> 07:46.020
es igual a un número que obtengo falso, pero ¿por qué es eso?

07:46.020 --> 07:49.200
Esto es esto debería ser igual a la derecha.

07:49.470 --> 07:54.240
Entonces, si usamos un objeto, esto se convierte en verdadero.

07:54.240 --> 08:01.470
De nuevo, lo más probable es que en tu vida diaria de programación nunca encuentres este problema.

08:01.680 --> 08:09.140
Pero quería demostrarle lo confuso que puede ser la precaución de tipos y si usted es el tipo de persona que

08:09.140 --> 08:14.860
simplemente ama la precaución de tipos y quiere leer todo al respecto y comprender todas estas complejidades

08:14.870 --> 08:22.880
que vincularé a la especificación real que habla sobre cómo me funciona el algoritmo de comparación de igualdad si leo esto, seré una

08:22.910 --> 08:26.440
buena lectura antes de dormir para que me duerma.

08:26.570 --> 08:28.970
Si te interesa, puedes echar un vistazo.

08:28.970 --> 08:36.980
La conclusión principal de aquí es que debería usar triples iguales porque la precaución de tipo en

08:37.220 --> 08:39.780
JavaScript puede ser realmente complicada.

08:39.970 --> 08:46.090
Por cierto, como pequeña nota al margen hay una captura de pantalla que tomé de Netflix viendo

08:46.270 --> 08:51.650
este gran documental hilarante y ves que los errores en el código son inevitables.

08:51.730 --> 08:58.300
Incluso el poderoso Netflix de vez en cuando tiene un problema en algún lugar, no un número.

08:58.300 --> 08:58.670
Todo bien.

08:58.870 --> 08:59.760
Eso es todo por ahora.

08:59.800 --> 09:01.230
Ya veo en la próxima.

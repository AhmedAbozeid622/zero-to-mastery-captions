WEBVTT

00:01.850 --> 00:03.660
Digite coerção.

00:03.890 --> 00:09.940
Se há uma coisa que vai fazer você arrancar todo o seu cabelo por frustração.

00:10.150 --> 00:19.290
É cautela ao digitar a origem do JavaScript no Google e olhar para algumas das postagens. Você verá muitas pessoas

00:19.290 --> 00:26.310
com raiva de algumas das coisas descoladas que o JavaScript faz e vamos falar sobre isso.

00:26.310 --> 00:32.700
vai lhe dar uma breve visão geral, porque fica realmente complicado e é algo

00:32.730 --> 00:39.390
que você deve entender e saber o que é, mas não precisa conhecer todos

00:39.510 --> 00:43.630
os detalhes, porque a maioria das partes complicadas.

00:43.680 --> 00:48.060
Bem, você não deve usá-lo em seu código, porque é confuso.

00:48.060 --> 00:50.500
Então, qual é o tipo causa.

00:51.620 --> 00:59.620
É algo como este igual a duas cordas um e igual a dois.

00:59.690 --> 01:08.000
É verdade que você vê cuidado com o tipo significa que quando a aparência é a parte

01:08.510 --> 01:13.070
esquerda e a direita do operador são tipos diferentes.

01:13.120 --> 01:22.150
Esse não é o tipo de string final, um deles será convertido em um valor equivalente pelo mecanismo JavaScript.

01:22.990 --> 01:27.740
Portanto, o mecanismo JavaScript dirá 1 igual à sequência 1.

01:27.940 --> 01:29.890
Eu acho que você quer dizer o número um.

01:29.890 --> 01:39.550
Então, vamos fazer isso por nós e comparar o número um com o número um agora, com base no

01:39.640 --> 01:47.100
tipo de definição cuidado, o idioma está convertendo um determinado tipo para outro tipo.

01:47.150 --> 01:55.460
Deixe-me fazer uma pergunta: todos os idiomas têm cautela?

01:55.490 --> 01:58.900
O que você acha que sim eles fazem.

01:59.470 --> 02:07.230
Porque sempre precisamos converter tipos entre programas para fazer coisas na memória.

02:07.290 --> 02:12.240
Tipos diferentes parecem completamente diferentes do que digitamos.

02:12.250 --> 02:16.290
Escreva o número cinco na memória física real.

02:16.290 --> 02:23.070
Oh, meu computador é representado uma vez em zero e todos os idiomas fazem isso.

02:23.070 --> 02:29.110
Portanto, há algum tipo de cautela de tipo em diferentes níveis da pilha.

02:29.430 --> 02:37.650
Acontece que o JavaScript tem uma causa de tipo especialmente pesada na natureza, porque é do tipo dinamicamente, e

02:37.650 --> 02:40.460
é por isso que faz isso.

02:40.500 --> 02:50.170
Vamos voltar ao exemplo no tipo JavaScript. Cuidado: quando você usa o sinal de igual duplo igual, duplo

02:50.170 --> 02:59.410
significa simplesmente comparar os dois valores e, se eles tiverem tipos diferentes, tente coagir um ao mesmo

02:59.920 --> 03:00.790
tipo.

03:02.330 --> 03:13.880
Se voltarmos e fizermos uma string aqui e eu fizer três iguais e eu corro, sou falso porque três iguais em

03:13.940 --> 03:17.180
JavaScript significa comparar com valores.

03:17.360 --> 03:25.300
Mas não tente amaldiçoar os valores, seja explícito com sua comparação e faça exatamente o que eu digo.

03:25.470 --> 03:32.000
Então, sempre há um momento em que você deve usar apenas dois iguais em vez de três iguais.

03:32.160 --> 03:33.340
Hum hmm.

03:33.510 --> 03:34.410
Eu direi isso.

03:34.410 --> 03:35.970
Não, não existe.

03:36.000 --> 03:43.930
Algumas pessoas podem argumentar que o dobro da igualdade pode realmente ter algumas aplicações interessantes nas quais

03:44.010 --> 03:51.890
coagimos algo e fazemos algum tipo de verificação rapidamente, mas não é um código previsível.

03:51.900 --> 03:53.000
Pode ser confuso.

03:53.040 --> 04:00.100
Poderia ser realmente um truque e truque para algumas pessoas, então sempre use três iguais em vez de dois.

04:00.300 --> 04:04.590
Agora, cuidado com o tipo não acontece apenas com o sinal de igual.

04:04.590 --> 04:06.870
Você também pode fazer uma declaração if.

04:07.020 --> 04:19.930
Portanto, se um retornar cinco e se eu executar isso bem, não há função aqui menos para o console.

04:21.030 --> 04:22.900
Estou gravando há um longo dia hoje, certo.

04:22.910 --> 04:24.560
Então me dê um tempo todo mundo.

04:24.640 --> 04:25.360
Tudo certo.

04:25.530 --> 04:29.540
Se eu executar este cinco está logado.

04:29.580 --> 04:30.450
Por que é que.

04:30.480 --> 04:35.400
Porque o curso de javascript é igual a verdadeiro.

04:35.490 --> 04:36.930
E se eu fizer zero aqui.

04:36.990 --> 04:44.220
Se eu fizer zero, nenhum curso de javascript é esse e diz bem, eu quero booleano aqui.

04:44.430 --> 04:53.050
Então, eu vou pegar o seu zero e transformar isso em falso agora. Esse tipo de cuidado faz com

04:53.050 --> 04:55.390
que haja muitos detalhes interessantes.

04:56.260 --> 05:02.470
E, de fato, há um pequeno site agradável que mostra algumas das comparações que o

05:02.470 --> 05:04.990
JavaScript faz com três iguais.

05:04.990 --> 05:08.920
Isso sem cautela, as coisas fazem sentido.

05:08.920 --> 05:13.860
Você vê que falso é igual a dois falsos e é isso.

05:13.910 --> 05:23.070
Você pode ver que a string falsa apenas é igual a triplo e retorna true com a string false novamente.

05:23.540 --> 05:26.740
Mas se fizermos o dobro, é igual a bem.

05:27.440 --> 05:27.810
Oh garoto.

05:27.830 --> 05:30.790
Isso é apenas uma bagunça, não é?

05:30.800 --> 05:41.210
Por exemplo, a string um é igual a true; uma matriz que contém um também é verdadeira quando comparada à

05:41.210 --> 05:42.880
string de um.

05:43.100 --> 05:47.200
E há tantos casos estranhos aqui.

05:47.390 --> 05:49.820
Se você quiser brincar com isso, vá em frente.

05:49.820 --> 05:53.330
Mas eu gostaria de ficar com iguais triplos.

05:53.360 --> 06:03.260
Você também pode ver algumas das declarações if aqui e alguns dos casos F que podem realmente ser complicados agora, se formos para

06:03.380 --> 06:10.550
esta página do MDMA à qual vou ligar neste vídeo, veremos que temos o dobro é igual

06:11.090 --> 06:12.410
ao triplo.

06:12.500 --> 06:20.270
Mas, também, algo chamado Object dot é bastante novo no JavaScript e este é interessante, que você

06:20.270 --> 06:23.380
provavelmente não verá com muita frequência.

06:23.390 --> 06:24.790
Mas acho interessante.

06:24.800 --> 06:31.730
Então, vamos falar sobre isso rapidamente. No JavaScript, existe um conceito de zero

06:32.360 --> 06:35.120
negativo e mais zero.

06:35.120 --> 06:35.850
Estranho eu sei.

06:36.200 --> 06:48.850
Então, se eu fizer zero negativo, o triplo é igual a zero e eu corro, sou verdadeiro, mas são coisas tecnicamente diferentes em

06:49.030 --> 06:55.180
JavaScript, para que eu possa realmente fazer o objeto dot is e,

06:59.190 --> 07:04.190
com os dois parâmetros, rodar e ficar falso.

07:04.400 --> 07:12.910
Agora, por que isso é útil se voltarmos a esta página, veremos que o objeto funciona praticamente da mesma forma que

07:12.940 --> 07:16.300
o triplo é igual, exceto em alguns casos.

07:16.420 --> 07:19.220
Esse é o 0 positivo e negativo.

07:19.390 --> 07:29.790
E se percorrermos todo esse caminho até um pouco desagradável e não um não, e podemos fazer um curso completo sobre o quão

07:29.790 --> 07:39.360
estranho esse número não é, mas se eu não tiver um número que não represente números em JavaScript e eu triplicar

07:39.700 --> 07:46.020
é igual a não um número, fico falso, mas por que é isso.

07:46.020 --> 07:49.200
Isto é, isso deve ser igual à direita.

07:49.470 --> 07:54.240
Portanto, se usarmos objeto que é isso, ele se torna verdadeiro.

07:54.240 --> 08:01.470
Novamente, provavelmente no seu dia a dia em programação, você nunca encontrará esse problema.

08:01.680 --> 08:09.140
Mas eu queria demonstrar para você como o cuidado com o tipo pode ser confuso e se você é o tipo de

08:09.140 --> 08:14.860
pessoa que adora o cuidado com o tipo e quer ler tudo sobre ele e entender todos

08:14.870 --> 08:22.880
esses meandros, vincularei à especificação real que fala sobre como o algoritmo de comparação de igualdade funciona para mim se eu ler isso, será

08:22.910 --> 08:26.440
uma boa leitura antes de dormir para me fazer dormir.

08:26.570 --> 08:28.970
Se você estiver interessado, pode dar uma olhada.

08:28.970 --> 08:36.980
O principal argumento a partir daqui é que você deve usar o triplo de iguais, pois cuidado com o tipo

08:37.220 --> 08:39.780
em JavaScript pode ser muito complicado.

08:39.970 --> 08:46.090
A propósito, como uma pequena anotação divertida, tirei uma captura de tela da Netflix assistindo a

08:46.270 --> 08:51.650
este grande documentário hilário e você vê que os erros no código são inevitáveis.

08:51.730 --> 08:58.300
Até o poderoso Netflix de vez em quando tem um problema em algum lugar, não em um número.

08:58.300 --> 08:58.670
Tudo certo.

08:58.870 --> 08:59.760
Por enquanto é isso.

08:59.800 --> 09:01.230
Eu vejo no próximo por.

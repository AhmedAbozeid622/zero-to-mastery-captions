WEBVTT

00:01.370 --> 00:10.140
E voltamos a falar sobre matrizes novamente na primeira seção. Quando falamos sobre matrizes, dissemos que elas se

00:10.190 --> 00:11.980
pareciam com colchetes

00:15.010 --> 00:18.230
e podemos colocar o que quisermos.

00:18.220 --> 00:20.920
Nós apenas colocamos alguns números aqui.

00:21.100 --> 00:27.340
Então, essas são matrizes e falamos sobre o fato de que podemos fazer quatro voltas com elas.

00:27.340 --> 00:32.590
Podemos fazer por cada um deles o que era novo no meu roteiro cinco.

00:32.720 --> 00:35.390
E hoje vamos aprender mais um pouco.

00:35.540 --> 00:41.990
Mas antes de fazer isso, vamos lembrar como o For Each funciona.

00:42.030 --> 00:47.200
Digamos que queremos multiplicar todos os números da matriz.

00:47.430 --> 01:01.860
Podemos apenas lembrar à Konst agora que podemos apenas usar nossa nova sintaxe E6 e podemos dizer que o novo array é igual ao ponto do array para

01:03.240 --> 01:08.170
cada um e está perfeitamente correto para cada array.

01:09.290 --> 01:15.750
Nós vamos usar um número e vamos usar como uma função novamente.

01:15.980 --> 01:17.690
Não há mais palavra de função.

01:17.690 --> 01:28.290
Tudo fica mais bonito assim com a seta gorda e, para cada número na matriz, o número de

01:29.040 --> 01:34.020
Whalsay multiplicado por dois, multiplique tudo por dois.

01:34.020 --> 01:38.810
Agora vamos ver o que isso nos dá o log do console.

01:39.830 --> 01:41.160
Você está

01:46.950 --> 01:47.700
indefinido.

01:47.860 --> 01:50.250
Bem, porque não é assim.

01:50.260 --> 01:58.510
Para cada trabalho certo para cada um, apenas diz que vou passar sobre esses elementos e multiplicar um número

01:58.510 --> 02:02.280
por dois, mas não estamos alterando a matriz.

02:02.380 --> 02:08.500
Se olharmos para a matriz agora, ainda é a mesma coisa de 1 a 10 16.

02:08.700 --> 02:14.190
Estamos apenas multiplicando aleatoriamente os números por dois, mas não o estamos armazenando em lugar algum.

02:14.830 --> 02:24.940
Se queremos fazer o que estamos fazendo, temos que dizer Konst double e diremos que double é

02:25.600 --> 02:31.760
uma matriz e, em seguida, push de ponto duplo.

02:31.820 --> 02:38.410
Então, estamos pressionando a matriz à medida que a percorremos várias vezes para.

02:38.480 --> 02:40.210
Agora vamos ver o que o dobro nos dá.

02:43.440 --> 02:48.760
Salvar uma atualização e olhar para isso.

02:48.820 --> 02:52.500
Recebo dois por 20 32.

02:52.570 --> 02:53.160
ESTÁ BEM.

02:53.380 --> 03:05.910
Agora, sobre os quais falaremos hoje é sobre filtro e redução de mapas. Eu diria que esses três são provavelmente

03:05.910 --> 03:11.810
os métodos mais importantes que você usará hoje.

03:11.880 --> 03:17.340
Javascript são super úteis, então comece a se familiarizar com eles.

03:17.390 --> 03:25.610
E sempre que você pensa em fazer algum tipo de loop, provavelmente você quer fazer um desses três.

03:25.680 --> 03:32.850
Vamos começar com o mapa da maneira acima de dobrar cada coisa na matriz

03:32.850 --> 03:52.430
e criar uma nova matriz bem com o mapa, podemos fazer com que o número do mapa de pontos da matriz de parada de mapa de custos seja o número de vezes e a maneira como o mapa funciona

03:52.490 --> 04:01.720
é que você sempre precisa retornar algo porque o que é diferente para mabbe do que para cada poço,

04:01.930 --> 04:10.690
para cada loop justo, é sobre algo e ele faz o que a função diz versus o

04:10.690 --> 04:11.530
array.

04:11.680 --> 04:19.330
Podemos fazer o que não conseguimos com cada um, que é um loop sobre cada elemento de cada número e

04:19.330 --> 04:21.100
retornar uma nova matriz.

04:21.110 --> 04:22.310
Deixe-me mostrar o que eu quero dizer.

04:22.790 --> 04:25.270
Toda vez que o array faz um loop.

04:25.310 --> 04:29.110
Então, digamos que aqui o primeiro seja o número um.

04:29.310 --> 04:36.340
Retornamos 1 vezes 2 que é colocado na matriz do mapa que agora é 2.

04:36.450 --> 04:39.370
E então vamos para o próximo número 2 vezes 2.

04:39.390 --> 04:46.290
Agora é adicionado à matriz 10 vezes 2 é adicionado à matriz e 16 vezes 2 é adicionado à matriz.

04:46.300 --> 04:47.740
É por isso que devolvemos.

04:47.860 --> 04:53.980
E, ao fazer isso, se o Konsole dog map map array

04:57.520 --> 05:00.460
e vamos atualizar aqui.

05:00.850 --> 05:07.890
E temos um colchete aqui, vamos tentar novamente.

05:08.010 --> 05:09.900
Você vê essa matriz de mapa.

05:09.900 --> 05:23.650
Portanto, a primeira linha é dupla e a segunda é a de joalharia, nomeando-as apenas para que saibamos a diferença.

05:23.670 --> 05:26.760
E vamos refazer tudo de novo.

05:27.260 --> 05:31.340
A propósito, você está se perguntando por que estou atualizando, em vez de apenas copiar e colar aqui.

05:31.350 --> 05:38.570
Bem, porque estamos usando o Konst, está dizendo que o array já foi declarado, então eu

05:38.580 --> 05:39.960
tenho que atualizar.

05:40.290 --> 05:41.520
Mas lá vai você.

05:41.520 --> 05:47.830
Para cada mapa olhando para esses dois, eles parecem estar fazendo a mesma coisa.

05:48.720 --> 05:54.570
Mas há uma diferença crítica entre o mapa e cada um deles, e estou aqui para lhe dizer que sempre

05:54.570 --> 06:00.160
que desejar fazer um loop, faça um loop simples e execute alguma ação em algo como uma matriz.

06:00.450 --> 06:06.980
Você deseja usar o mapa sobre para cada um para cada operação não pode fazer nada.

06:07.020 --> 06:15.310
Você pode simplesmente deixar esse campo completamente em branco ou fazer o log do Konsole, porque tudo para cada um deles

06:15.350 --> 06:24.550
é iterar, o que vai repetir um por um sobre uma coleção de elementos como 1 a 10 e 16 e aplicar qualquer operação

06:24.550 --> 06:27.440
que for solicitada em cada elemento .

06:27.460 --> 06:31.800
Agora o mapa, por outro lado, tem uma restrição na operação.

06:31.930 --> 06:35.230
Ele espera que a operação retorne um elemento.

06:35.230 --> 06:42.580
Assim, com o mapa com para cada um, você pode ter várias linhas de código fazendo todas essas coisas loucas versus mapear com

06:42.970 --> 06:43.740
o mapa.

06:43.750 --> 06:46.900
Você sempre tem um elemento de retorno.

06:46.930 --> 06:54.280
O mapa itera novamente através de uma coleção de elementos que aplicam a operação em cada

06:54.730 --> 07:00.510
elemento e, finalmente, armazenam o resultado de cada chamada da operação.

07:00.520 --> 07:06.970
É isso em outra coleção, que é a matriz de mapas.

07:07.010 --> 07:12.920
Em outras palavras, o mapa transforma a matriz.

07:12.920 --> 07:22.490
Ele cria uma nova matriz, que é a matriz de mapas versus para cada uma, que apenas executa um monte de ações com base na

07:22.490 --> 07:27.620
matriz e o que essas ações são não são realmente tão limitadas.

07:27.620 --> 07:34.230
Se queremos retornar uma nova matriz, temos que criar nossa própria matriz e pressionar.

07:34.370 --> 07:39.260
E você pode notar aqui algo sobre o que falamos na

07:39.260 --> 07:49.990
última seção, quando falamos sobre funções avançadas, e essa é a idéia de efeitos colaterais. Se voltarmos para a frente, podemos fazer vários efeitos

07:49.990 --> 07:52.010
colaterais dentro da função.

07:52.210 --> 08:00.650
Você pode aplicar a lei do Konsole, criar uma nova matriz que pode ser enviada por push para essa matriz e retornar indefinida.

08:00.650 --> 08:07.960
Você viu que quando fizemos o primeiro para cada um ou mesmo agora, não estamos realmente retornando nada.

08:08.010 --> 08:12.120
Então, estamos retornando indefinidos versus com um mapa.

08:12.220 --> 08:15.700
Todos esses efeitos colaterais desapareceram teoricamente.

08:15.840 --> 08:19.190
E porque com um mapa, temos que voltar.

08:19.240 --> 08:22.800
Deixe-me mostrar-lhe se eu não voltar aqui, vamos ver o que acontece.

08:30.910 --> 08:34.280
Recebo mapa indefinido indefinido indefinido indefinido.

08:34.540 --> 08:37.660
Imediatamente sabemos que estamos fazendo algo errado que precisamos retornar.

08:38.140 --> 08:47.230
E, como mencionamos na seção anterior, agora criamos uma função pura, na qual não há dúvida sobre o

08:47.230 --> 08:48.790
retorno ou não.

08:49.660 --> 08:59.130
Temos entradas de uma função sem efeitos colaterais que simplesmente retornam um valor.

08:59.180 --> 09:01.350
Mais uma vez um conceito muito importante.

09:01.370 --> 09:05.990
Queremos manter as coisas agindo da maneira esperada.

09:06.080 --> 09:13.310
Não queremos ter um código que mora em um site, digamos, por quatro anos

09:13.310 --> 09:21.350
e alguém aparece que não o conhece intimamente e, de repente, todos esses efeitos colaterais acontecem

09:21.500 --> 09:23.950
que eles desconhecem. .

09:24.080 --> 09:31.540
Novamente, queremos escrever Foxtons simples e puros e é isso que o mapa nos permite fazer.

09:31.650 --> 09:34.980
E a outra coisa importante é que não estamos mudando a matriz.

09:34.980 --> 09:40.830
Essa matriz permanece exatamente igual à matemática, porque estamos sempre apenas fazendo uma nova cópia

09:40.830 --> 09:44.420
da matriz e nunca estamos alterando os dados.

09:44.490 --> 09:44.910
Tudo certo.

09:44.910 --> 09:46.090
Então esse foi o mapa.

09:46.200 --> 09:48.100
Vamos trazer de volta o retorno aqui.

09:48.420 --> 09:51.940
E vamos trazer de volta o cônsul.

09:51.960 --> 09:59.160
Também quero mostrar que, quando você tem apenas um único parâmetro com uma

09:59.640 --> 10:04.400
função aérea, pode realmente evitar os colchetes.

10:04.560 --> 10:11.410
E, novamente, porque estamos retornando e estamos retornando apenas uma única linha, aqui podemos trabalhar com

10:11.410 --> 10:12.970
taquigrafia, que é

10:16.290 --> 10:19.020
exatamente essa faxineira que faz o outlook.

10:19.250 --> 10:24.050
Vamos testar novamente isso.

10:24.060 --> 10:24.490
Ai está.

10:24.490 --> 10:26.070
Tudo está bonito.

10:26.070 --> 10:35.280
Veja a diferença entre o mapa e o filtro para cada um dos próximos.

10:35.600 --> 10:39.460
Agora, com filtro, podemos dizer matriz de filtros.

10:40.310 --> 10:51.230
E como o nome sugere, podemos filtrar nossa matriz com uma condição no nosso caso, podemos dizer que os Blits retornam todos os

10:51.350 --> 11:00.010
elementos na matriz que estão acima, para que possamos dizer que o número é maior que 5.

11:00.310 --> 11:11.360
E, como no mapa, isso retorna uma nova matriz, portanto, temos que retornar algo, porque a matriz de filtro conterá

11:11.360 --> 11:12.890
essas informações.

11:12.890 --> 11:23.620
Então, a maneira como você lê isso é filtrar esse Saray, que está aqui em cima, à medida que você avança um por

11:24.190 --> 11:31.150
um, para que um número seja o primeiro, um retorno é maior que 5.

11:31.190 --> 11:34.100
Nesse caso, vai dizer que é falso.

11:34.310 --> 11:38.290
Portanto, não vamos adicionar isso à matriz de filtros.

11:39.090 --> 11:43.350
Em seguida, itera para dois é muito maior que cinco.

11:43.350 --> 11:44.580
Não, isso é falso.

11:44.580 --> 11:50.940
Portanto, ele não entrará na matriz de filtros 10 maior que 5.

11:51.390 --> 11:52.550
Sim, isto é bom.

11:52.560 --> 11:57.520
Dez vai para a matriz de filtros e é 16 maior que 5.

11:57.870 --> 11:58.350
Sim.

11:58.500 --> 12:03.100
Então 16 irá para a matriz.

12:03.300 --> 12:08.070
E, novamente, porque é apenas uma linha, podemos fazer uma forma abreviada aqui.

12:11.410 --> 12:19.450
E agora, se cancelarmos o registro, diremos filtro filtro matriz.

12:22.590 --> 12:39.920
E, atualizando, obtemos o filtro contendo 10 e 16 se fizermos igual a 5, enquanto nesse caso obtemos uma matriz vazia porque nada

12:39.920 --> 12:43.850
é igual a cinco.

12:43.910 --> 12:46.000
Então você pode colocar qualquer condição que quiser aqui.

12:46.010 --> 12:51.480
Se ele tinha força e você quer ver se contém uma palavra Olá, você pode fazer isso também.

12:51.560 --> 12:56.210
Tudo o que você precisa fazer é retornar verdadeiro ou falso se retornar falso.

12:56.210 --> 13:02.050
Ele não entrará no array se retornar true, enquanto entrará no array.

13:02.050 --> 13:04.210
Muito legal, muito útil.

13:04.500 --> 13:05.430
O que mais nos temos.

13:05.440 --> 13:11.550
Bem, o último que quero lhe mostrar é reduzir e isso é realmente muito poderoso, você pode fazer muito com

13:11.550 --> 13:12.250
o Reduce.

13:12.330 --> 13:16.910
Você pode realmente filtrar e mapear com reduzir.

13:17.040 --> 13:19.110
Portanto, é um método realmente poderoso.

13:19.410 --> 13:22.470
Mas vou lhe mostrar uma maneira fácil de começar.

13:23.910 --> 13:27.810
Bem, o que vamos fazer

13:30.590 --> 13:43.270
é dizer que o Konst reduz a matriz que ele chama e, novamente, isso retorna uma nova matriz que

13:43.300 --> 13:50.080
economizamos reduzir e reduzir leva algo chamado acumulador e número.

13:50.120 --> 13:52.490
Agora, obviamente, este pode ser qualquer nome.

13:52.510 --> 13:58.190
Às vezes, você verá um CC para um acumulador, deixaremos assim por enquanto, para que possamos saber qual

13:58.190 --> 13:59.180
é o número.

13:59.180 --> 14:05.860
O número é de 1 a 10 e 16, mas o que é acumulador.

14:06.230 --> 14:15.140
Acumulador de poço é algo onde podemos armazenar as informações que acontecem no corpo da função.

14:15.140 --> 14:25.180
Deixe-me explicar o acumulador mais o número e novamente porque reduzimos o retorno de uma matriz.

14:25.260 --> 14:27.930
Temos que retornar um valor.

14:28.210 --> 14:36.030
E o que estamos dizendo aqui é que toda vez que você itera Então, digamos que o primeiro turno.

14:36.060 --> 14:42.220
Você tem o acumulador número um mais o número um é igual.

14:42.310 --> 14:49.050
Digamos que se o acumulador é zero, todos são iguais a 1 agora zero mais um é igual a 1.

14:49.270 --> 14:57.160
Quando 2 chega, fazemos 1 mais 2, porque o acumulador lembra o que havia anteriormente

14:57.160 --> 15:03.260
e depois 10 chega e você passa três mais 10.

15:03.270 --> 15:05.540
Agora, o que é o acumulador?

15:05.540 --> 15:10.800
Nós não o definimos em nenhum lugar após refazer a função.

15:11.010 --> 15:14.220
Você tem um segundo parâmetro.

15:14.340 --> 15:20.460
E aqui podemos especificar o que queremos que nosso acumulador marque com o valor padrão.

15:20.910 --> 15:23.740
No nosso caso, digamos zero.

15:23.740 --> 15:28.190
Agora, se eu faço o Konsole, o diálogo

15:31.000 --> 15:32.890
reduz e reduz.

15:33.220 --> 15:34.370
Vamos ver o que acontece.

15:39.150 --> 15:48.940
Temos redução de 29 porque 10 mais 16 é 26 mais três é 29.

15:48.980 --> 16:05.560
Se eu mudei para 5 e copio e tente novamente, obteremos 34 porque o número inicial é agora cinco.

16:05.600 --> 16:06.570
Muito legal.

16:06.610 --> 16:07.550
Então é isso.

16:07.660 --> 16:13.820
Quero que você se lembre desses três métodos porque os usará muito em sua carreira.

16:13.810 --> 16:15.490
Eles são muito, muito úteis.

16:15.550 --> 16:24.290
Eles são puros, o que significa que toda vez que fazemos uma operação, quaisquer que sejam as entradas que recebemos, sempre retornam um

16:24.290 --> 16:24.940
valor.

16:24.980 --> 16:28.610
E não há efeitos colaterais.

16:28.690 --> 16:33.270
E como você pode ver, eles são muito fáceis e simples de ler.

16:33.400 --> 16:36.830
Então, acostume-se a eles e boa sorte com os

16:36.880 --> 16:40.130
exercícios após este vídeo. Vejo você no próximo tchau.

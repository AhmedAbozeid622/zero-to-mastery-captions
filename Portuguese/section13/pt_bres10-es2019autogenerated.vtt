WEBVTT

00:01.230 --> 00:02.620
Olá pessoal.

00:02.700 --> 00:09.090
Agora estamos prontos para o script yes 10 ou Xmas 20 19.

00:09.120 --> 00:09.900
Está certo.

00:09.900 --> 00:10.620
Todo ano.

00:10.650 --> 00:14.460
Eles estão constantemente tentando melhorar o idioma e isso é javascript.

00:14.460 --> 00:18.370
E agora a ESPN é a mais recente.

00:18.410 --> 00:23.750
Então, que novos recursos obtemos nesta nova versão do JavaScript.

00:24.650 --> 00:27.890
Bem, felizmente para você, não há muitos.

00:27.920 --> 00:38.290
Então, vamos começar com o meu favorito e ele é chamado flat and flat é um método que podemos usar

00:38.530 --> 00:40.610
em uma corrida.

00:40.640 --> 00:50.470
Deixe-me mostrar o que quero dizer, digamos que tenho uma variável de matriz que contém uma matriz muito interessante de

00:50.470 --> 00:57.640
1 2 3 4 5 se agora eu executar o ponto de matriz plana.

00:57.680 --> 01:02.050
Vamos copiar esse código e executá-lo aqui.

01:02.100 --> 01:03.570
O que você acha que acontecerá.

01:04.140 --> 01:09.400
Bem, absolutamente nada, voltamos a uma nova matriz.

01:09.420 --> 01:17.540
Parece, mas parece exatamente o mesmo, mas é aqui que o Flight fica emocionante.

01:17.550 --> 01:20.350
Imagine se isso tivesse matrizes aninhadas.

01:20.430 --> 01:29.190
Assim, por exemplo, dois e três em que é sua própria matriz e, em seguida, quatro e cinco também eram uma matriz aninhada dentro

01:29.190 --> 01:30.950
de uma matriz maior.

01:31.170 --> 01:36.900
Se agora eu copiar isso e vamos chamar essa matriz para descobrir.

01:36.930 --> 01:42.330
Copie isso e cole aqui. Ei, confira.

01:42.530 --> 01:46.160
Temos uma nova matriz que é achatada.

01:46.340 --> 01:50.700
Ou seja, não há mais matrizes aninhadas.

01:50.920 --> 01:58.040
Tudo bem, vamos continuar e o que acontece se tivermos o array 3

01:58.190 --> 02:09.570
e o array 3 ainda mais aninhados do que tínhamos antes, digamos que temos um dois três assim e talvez tenhamos

02:10.230 --> 02:14.270
um cinco bem aninhado como aquele.

02:14.310 --> 02:21.450
Então agora temos uma matriz, existe outra matriz e dentro dela existe outra matriz.

02:21.510 --> 02:23.110
O que você acha que vai acontecer aqui.

02:23.410 --> 02:27.360
Deseja copiar e colar, execute este código.

02:27.380 --> 02:28.420
Tudo certo.

02:28.580 --> 02:36.550
Então, recebo uma nova matriz de volta, mas vemos que, na verdade, não existe uma matriz completamente plana.

02:36.560 --> 02:44.970
Em vez disso, temos um dois três quatro, mas cinco foram achatados em apenas um nível,

02:45.150 --> 02:48.370
portanto, basicamente, esses suportes foram removidos.

02:48.380 --> 02:54.470
Agora, o interessante do flat é que podemos dizer quantas camadas voar na matriz.

02:54.620 --> 02:59.590
Portanto, se voltarmos ao nosso exemplo e aqui o padrão era 1.

02:59.660 --> 03:01.370
Mas se mudarmos

03:04.260 --> 03:13.220
para dois agora, vamos copiar e colar, vamos atualizar e executar novamente, verificando se temos uma matriz completamente achatada.

03:13.800 --> 03:20.680
Então aqui eu posso dizer quantas vezes eu quero voar ou quantas camadas eu quero voar na matriz.

03:20.750 --> 03:20.990
Tudo certo.

03:21.000 --> 03:23.580
Mas eu tenho um exemplo realmente emocionante para você.

03:23.580 --> 03:25.620
Prepare-se para isto.

03:25.650 --> 03:30.510
Parabéns, você acabou de se tornar o proprietário do Jurassic Park.

03:30.510 --> 03:39.600
Você tem um parque com todas essas criaturas antigas e o clima aqui é extremamente perigoso.

03:39.600 --> 03:40.180
É por isso.

03:40.200 --> 03:48.090
Bem, está em sua própria área contida no parque, com muitas barricadas por aí, porque não queremos que

03:48.090 --> 03:50.090
o teste fique selvagem.

03:50.190 --> 03:52.710
Mas aqui está o problema.

03:52.790 --> 03:55.190
Você é um cara mau no Jurassic Park.

03:55.190 --> 04:02.610
Se eu lhe perguntasse, ei, como você pode flanquear completamente essa matriz, como você faria isso?

04:03.570 --> 04:04.560
Pause o vídeo.

04:04.560 --> 04:05.400
Pense nisso.

04:05.400 --> 04:07.070
Pronto para a resposta.

04:07.080 --> 04:16.980
Bem, podemos fazer o Jurassic Park pontual e, em seguida, você pode contar quantas matrizes estão aninhadas

04:16.980 --> 04:20.730
aqui, mas há um truque aqui.

04:21.830 --> 04:31.870
Talvez eu pudesse fazer 50, vamos ver o que acontece se eu copiar isso, vamos tornar isso um pouco maior.

04:31.990 --> 04:33.480
Eu atualizo aqui.

04:33.580 --> 04:35.190
Copie e cole isso.

04:35.230 --> 04:36.930
Vamos ver o que acontece.

04:37.060 --> 04:40.940
E Jurassic Park deve ser Jurassic Park.

04:40.960 --> 04:42.430
Vamos copiar isso novamente.

04:42.460 --> 04:46.060
Vamos atualizar.

04:46.090 --> 04:47.070
Tudo certo.

04:47.170 --> 04:52.220
Todas as barricadas caíram e os animais agora estão ficando selvagens.

04:52.370 --> 04:56.800
E eu escolhi aleatoriamente 50 porque sabia que 50 não eram.

04:56.870 --> 05:02.720
Bem, quantas matrizes aninhadas temos agora no exercício após este vídeo.

05:02.860 --> 05:10.600
Vou lhe mostrar um truque legal para garantir que possamos financiar o nível máximo, mas isso é para

05:10.600 --> 05:11.680
o exercício.

05:11.720 --> 05:20.440
Outra coisa realmente útil que você pode fazer com o flat é, digamos, que você receba várias

05:20.440 --> 05:30.130
entradas e essas entradas de seus usuários entrem, e talvez recebamos Bob, temos Sally digitando seu nome, mas também

05:30.130 --> 05:38.440
temos várias entradas que são completamente vazio com talvez Cindy no final aqui usando flat.

05:38.440 --> 05:47.870
Na verdade, podemos colocar as entradas offline e limpar nossos dados, para que eu possa dizer que as entradas estão no mesmo nível.

05:48.100 --> 05:58.000
E se eu copiar e colar esse visual, ele limpará os dados para mim, o que é realmente muito bom.

05:58.070 --> 05:58.550
Tudo certo.

05:58.550 --> 06:10.980
O próximo recurso do ESPN é mapa plano e mapa plano, como o nome sugere, nos permite usar uma função plana e

06:11.910 --> 06:17.280
a função ou método de mapa em uma matriz.

06:17.370 --> 06:19.680
Então, vamos fazer algo divertido aqui.

06:19.740 --> 06:25.100
Digamos que temos o Jurassic Park novamente e desta vez vamos usar o mapa plano.

06:25.140 --> 06:32.220
Então, digamos Jurassic Park e chamaremos essa nova variável.

06:32.290 --> 06:33.650
Vamos fazer conceito.

06:33.800 --> 06:35.210
Parque jurassico.

06:35.420 --> 06:40.020
Caos e esse caos terá.

06:40.020 --> 06:44.230
Enquanto a matriz do Jurassic Park que tínhamos acima.

06:44.270 --> 06:46.160
Vamos tornar isso um pouco maior.

06:46.370 --> 06:49.730
E agora podemos usar um mapa plano para fazer algo interessante.

06:51.110 --> 07:01.670
Eu posso dizer para cada item que vamos nos divertir, vamos pegar uma criatura e esta criatura usando funções

07:01.670 --> 07:06.730
de flecha vai pegar a criatura mais o T-Rex.

07:06.740 --> 07:10.310
Então, eu vou copiar o T-Rex aqui.

07:10.430 --> 07:16.910
Então cada criatura receberá um T-Rex como vizinho, o que não é bom.

07:16.910 --> 07:23.840
Todos eles serão comidos pelo T-Rex é o T-Rex que eles não podem carnivorar. Não tenho certeza de que você precisará pesquisar no Google

07:23.840 --> 07:24.850
por conta própria.

07:25.240 --> 07:25.760
Tudo certo.

07:25.820 --> 07:36.710
Portanto, temos o mapa plano do Jurassic Park, por isso estou achatando o Jurassic Park e, em seguida, mapeando essa matriz

07:36.840 --> 07:42.170
achatada e fazendo algum tipo de função de mapa nele.

07:42.920 --> 07:53.230
Então, vamos ver o que acontece se eu copiar e colar agora, se eu verificar o que é o caos do

07:53.410 --> 08:04.680
Jurassic Park e pressionar Enter, oh garoto, veja que temos vizinhos com todas as criaturas e, enquanto é um caos absoluto e Jurássico O

08:04.740 --> 08:11.940
mapa plano de estacionamento permite-nos usar a função básica do mapa e nivelar o resultado

08:12.030 --> 08:14.980
a uma profundidade de um.

08:15.000 --> 08:16.500
Tudo bem, vamos continuar.

08:16.590 --> 08:19.030
Em seguida é muito, muito simples.

08:19.050 --> 08:22.970
Digamos que você receba um email de usuário e um email de usuário.

08:22.980 --> 08:29.880
Bem, isso é digitado de forma incorreta, então temos um monte de espaços e temos

08:30.000 --> 08:39.200
o Eddie the Eagle no gmail dot com que recebemos do usuário ou talvez também tenhamos o e-mail do usuário.

08:39.660 --> 08:50.610
E desta vez em torno de Johnny Dangerous em G. M. o ponto entra suas informações, mas temos novamente

08:50.610 --> 08:52.580
alguns espaços em branco.

08:52.690 --> 08:53.930
O que podemos fazer.

08:53.980 --> 09:04.890
Bem, com o novo recurso do iOS 10, podemos simplesmente dizer que o ponto de e-mail do usuário apara o

09:04.890 --> 09:17.600
início de uma sequência e ele apara o início e o e-mail do usuário também pode dizer apara e apara o final da sequência.

09:17.830 --> 09:20.800
Então, vamos consolar o diálogo e registrar o

09:24.300 --> 09:33.460
que acontece se eu copiar isso e garantir que declaremos essas variáveis, portanto seja const e certifique-se de que eu possa cheirar o

09:33.490 --> 09:34.600
email corretamente.

09:34.600 --> 09:39.220
Se eu copiar isso agora e inseri-lo aqui, não

09:42.230 --> 09:48.870
sei se você pode ver, mas agora minhas cordas não possuem espaços em branco.

09:49.040 --> 09:57.890
Se eu verificar o e-mail do usuário aqui, você verá que o espaço em branco ainda está lá, mas o novo

09:58.820 --> 10:04.720
e-mail do usuário da cadeia de caracteres gerado não terá espaços em branco.

10:04.840 --> 10:08.840
Legal e fácil.

10:08.890 --> 10:10.750
Tudo bem, estamos voando por estes.

10:10.780 --> 10:11.760
Qual é o próximo.

10:11.770 --> 10:13.650
Temos apenas mais alguns.

10:13.720 --> 10:15.320
Na verdade, restam mais dois.

10:15.400 --> 10:18.570
O próximo é chamado de entradas de formulário.

10:18.760 --> 10:23.950
Transforma uma lista de pares de valores-chave em um objeto.

10:23.950 --> 10:29.260
Deixe-me mostrar o que eu quero dizer, vamos esclarecer isso e vamos apenas comentar.

10:29.260 --> 10:30.440
Tudo isso.

10:30.880 --> 10:36.650
Talvez abaixe-o e concentre-se neste.

10:36.770 --> 10:48.630
Imagine que tivéssemos alguns perfis de usuário que recebemos, mas esses perfis de usuário foram formatados da maneira

10:48.630 --> 10:49.560
errada.

10:49.560 --> 10:56.850
Então, digamos que uma matriz e dentro de uma matriz temos os perfis de usuário de um jogo.

10:56.850 --> 11:07.330
Então, vamos chamá-lo de comandante Tom como o nome do jogador e comandante Tom tem 23 anos.

11:07.360 --> 11:20.700
Em seguida, temos um digamos que uma matriz de Derek Zealander e Derek Zealander é digamos 40, vamos tornar

11:20.700 --> 11:23.960
isso um pouco maior.

11:24.110 --> 11:34.190
E finalmente, temos uma matriz que Hansel e Hansel têm 18 anos, por isso temos esses perfis de usuário, mas como uma corrida, eles não são

11:34.250 --> 11:36.100
realmente úteis no momento.

11:36.110 --> 11:44.720
Não seria ótimo se pudéssemos convertê-los em um objeto em que cada nome de usuário está associado a um H.

11:45.320 --> 11:48.460
Bem, é exatamente para isso que as entradas são usadas.

11:48.740 --> 12:03.320
Simplesmente criamos um formulário de ponto de objeto ou a partir de entradas, para que as entradas e as entradas recebam uma matriz

12:03.320 --> 12:05.150
como esta.

12:05.150 --> 12:13.320
Então, vamos criar perfis de usuários aqui e ver o que acontece.

12:13.340 --> 12:14.210
Copie este

12:17.050 --> 12:18.350
código e cole-o aqui.

12:20.100 --> 12:21.270
Ei, olha isso.

12:21.480 --> 12:24.940
Agora temos um objeto com o comandante Tom.

12:24.940 --> 12:26.030
Vinte e três.

12:26.040 --> 12:34.320
Derek Zealander tem uma chave e um valor de 40 e Hansel tem uma chave de Hansel e valor de dezoito.

12:34.440 --> 12:41.700
Agora, o nome pode disparar algo enquanto você está assistindo isso, porque no sim oito falamos

12:42.570 --> 12:45.370
sobre algo chamado de entradas corretas.

12:45.720 --> 12:54.860
As entradas de ponto de objeto nos permitiram fazer bem a coisa exatamente oposta.

12:54.880 --> 13:04.540
Então, por exemplo, se este era agora um objeto, se eu fizer entradas de objeto neste objeto agora.

13:04.540 --> 13:07.150
Então, vamos copiar e colar as

13:09.770 --> 13:13.100
atualizações, recebo exatamente o que tinha originalmente de volta.

13:13.130 --> 13:16.570
Então, das entradas, o nome das entradas simplesmente vem.

13:16.640 --> 13:18.880
Entradas de ponto de objeto bem.

13:18.950 --> 13:19.310
Tudo certo.

13:19.310 --> 13:19.800
Tudo certo.

13:19.910 --> 13:21.310
Um último, eu prometo.

13:21.310 --> 13:22.500
E então terminamos.

13:22.640 --> 13:34.600
A última parte é uma atualização de um recurso que temos em JavaScript, que é o bloco try

13:34.600 --> 13:36.330
catch assim.

13:36.390 --> 13:42.810
Agora, esse bloco try catch é algo sobre o qual falaremos muito mais quando entrarmos na

13:43.170 --> 13:45.530
parte javascript assíncrona do curso.

13:45.780 --> 13:53.730
Mas, essencialmente, o bloco try and cache em JavaScript nos permite experimentar um pedaço de código e se

13:53.730 --> 13:56.350
há algum erro para capturá-los.

13:56.400 --> 14:09.560
Por exemplo, se eu ouvir, digamos quatro mais cinco e eu executar este pedaço de código, clique em Executar, recebo

14:09.670 --> 14:10.430
nove.

14:10.590 --> 14:15.970
É exatamente a mesma coisa que escrevemos quatro mais cinco.

14:15.980 --> 14:23.810
A única diferença é que, dentro desse bloco de tribo, estamos dizendo ao javascript Ei, tente isso e se houver

14:23.810 --> 14:29.110
algum erro na linha três aqui, faça algo dentro do bloco de cache.

14:29.750 --> 14:44.580
Então, por exemplo, eu poderia dizer o log de ponto do console que você errou e agora, se o

14:45.090 --> 14:56.010
fizermos, digamos verdadeiro ou verdadeiro, mais oi fi, copie e cole e execute

14:56.010 --> 14:57.830
este código.

14:58.350 --> 15:07.470
Por isso, tentei isso em javascript que é javascript válido, porque ele se torna verdadeiro em uma string e a combina

15:07.470 --> 15:08.500
com high.

15:08.640 --> 15:12.230
Mas se vamos dizer fazer uma variável que não vimos antes.

15:12.240 --> 15:21.770
Então, em vez de true, digamos que tenhamos um fogo variável bob executado, eu chego ao bloco de cache que diz que você errou porque,

15:22.040 --> 15:29.990
enquanto isso ocorre por meio de um erro e assim que gera um erro, ele captura e aqui está a

15:29.990 --> 15:30.710
coisa.

15:30.710 --> 15:39.050
Você realmente viu um novo recurso aqui na ESPN porque, no dia anterior ao sim 10, para

15:39.050 --> 15:47.280
que esse código fosse detectado, era necessário transmitir a ele um objeto ou parâmetro de erro.

15:47.280 --> 15:49.050
Então eu poderia ter chamado isso do que eu quiser.

15:49.110 --> 15:55.850
Então eu tive que cometer um erro como esse para poder dizer erro.

15:56.040 --> 16:08.080
Portanto, se eu copiar essa atualização e deixar o Bob aqui para que possamos errar, você ficará confuso, mas também pego o

16:08.080 --> 16:12.150
erro, que é um erro de referência.

16:12.250 --> 16:13.420
Bob não está definido.

16:14.260 --> 16:21.970
Portanto, antes tivemos que passar um parâmetro, caso contrário, todo esse bloco de código, mesmo se estivesse funcionando corretamente, na

16:22.390 --> 16:25.840
verdade erro, porque não passamos o parâmetro com.

16:25.840 --> 16:32.260
Sim, Stan, temos uma atualização em que você não é forçado a usar esse parâmetro se não quiser.

16:32.290 --> 16:37.210
Novamente, isso é algo que abordaremos mais adiante no curso, quando falamos sobre

16:39.260 --> 16:44.190
javascript assíncrono, oh garoto, que parecia muito, mas quero dizer que não era muita chuva.

16:44.330 --> 16:46.760
Agradável e fácil agradável e simples.

16:46.760 --> 16:48.670
Vejo você no próximo vídeo.

16:48.670 --> 16:49.130
Tchau tchau.

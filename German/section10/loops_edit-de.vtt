WEBVTT

00:01.210 --> 00:07.830
Willkommen zurück. Bis zu diesem Punkt haben wir gelernt, dass Code nur von oben nach unten ausgeführt wird.

00:07.830 --> 00:14.020
Nur in einer geraden Linie. Wir haben über Conditionals gelernt, wo wir eine 'if-Anweisung' hinzufügen und haben können

00:14.020 --> 00:17.380
Geh in die eine oder andere Richtung, geh in die andere Richtung.

00:17.710 --> 00:24.220
Dann lernten wir auch 'Wenn anders' und 'sonst wenn'.

00:24.310 --> 00:35.680
Also 'wenn', 'sonst wenn', 'sonst wenn', 'sonst'. Und was wäre, wenn wir so etwas machen wollten. Etwas, wo wir bleiben

00:35.680 --> 00:42.280
mach es immer und immer wieder. Und das wird "Looping" genannt, und darüber werden wir in diesem Video lernen.

00:42.640 --> 00:49.750
Und wie Sie in unserem Überblick, JavaScript-Looping, sehen können, werden wir das in diesem Video durchgehen.

00:49.910 --> 00:50.720
Lass uns anfangen.

00:52.480 --> 01:02.160
Ich habe hier ein leeres "Skript" -Tag. Das hängt wiederum mit unserem HTML zusammen und wir beginnen mit einer "To-Do-Liste".

01:02.160 --> 01:12.760
Und eine To-Do-Liste hat ... oder sollte ein Array sein. Und wir wollen vielleicht "Reinraum" haben.

01:12.880 --> 01:25.730
Wir wollen "Zähne putzen". Vielleicht "Übung", sollte auf jeden Fall "Javascript" lernen.

01:25.790 --> 01:28.910
Und schließlich sollten wir "gesund essen".

01:29.090 --> 01:32.330
Gut. Also haben wir eine To-Do-Liste.

01:33.200 --> 01:39.950
Nehmen wir an, wir wollten ein Ausrufezeichen am Ende dieser To-Do-Liste hinzufügen.

01:39.950 --> 01:43.140
Ich meine, das sind alle wirklich wichtig, und das möchten wir betonen.

01:43.170 --> 01:49.190
Aber, ich meine, das ist irgendwie langweilig, oder? Ich muss eins nach dem anderen gehen und ein Ausrufezeichen hinzufügen, ein hinzufügen

01:49.220 --> 01:50.130
Ausrufezeichen.

01:50.130 --> 01:54.310
Und stellen Sie sich vor, wenn 'Todo-Liste' Hunderte von Zeilen wäre.

01:55.470 --> 01:58.410
Und als Programmierer wollen wir Dinge effizient machen.

01:58.410 --> 02:00.310
Dafür haben wir Maschinen.

02:00.720 --> 02:06.930
Also, fügen wir etwas Looping dazu hinzu. Um eine Schleife in JavaScript zu machen

02:06.930 --> 02:12.530
eine der wichtigsten Möglichkeiten, wie Sie es tun können, ist eine "for-Schleife". Und du wirst hier eine neue Syntax lernen.

02:12.540 --> 02:19.410
Und sei gewarnt! Es sieht zunächst verwirrend aus, aber es ist wieder eines dieser Dinge, du musst es ein paar machen

02:19.410 --> 02:21.890
mal - und du wirst den Dreh raus bekommen.

02:21.900 --> 02:27.370
Also ist die erste Variable 'i' gleich '0', die wir tun werden.

02:27.390 --> 02:33.240
Wenn 'i' weniger ist als 'todos.length'.

02:33.480 --> 02:37.780
Und dann machen wir 'i ++'.

02:37.780 --> 02:40.220
Mach dir keine Sorgen, ich werde erklären, was das bedeutet.

02:40.270 --> 02:47.310
Wir haben die geschweiften Klammern und dann hier für jetzt lassen Sie uns einfach warten und erklären, was passiert.

02:47.320 --> 02:53.410
Also sage ich "für", was ein JavaScript-Sprichwort ist:Wir machen eine Schleife.

02:53.890 --> 02:59.200
Jetzt in dieser Schleife werden wir als erstes sagen:'i' ist gleich '0'.

02:59.200 --> 03:01.220
Also ist nur eine Zufallsvariable "i":03:01.300 --> 03:04.840
es ist üblich, in einer "for" -Schleife verwendet zu werden - steht für einen "Index".

03:04.840 --> 03:07.080
Also beginnt 'ich' mit '0'.

03:07.090 --> 03:13.670
Wir haben ein Semikolon, was bedeutet, dass das Ende des Ausdrucks ist, wir haben nur die 'i' Variable der '0' zugewiesen

03:14.330 --> 03:18.840
und dann in der nächsten Zeile heißt es:'i', was in diesem Moment '0' ist.

03:19.160 --> 03:27.150
Wenn das weniger als die "Todos" -Länge und "Todos.Length" ist - wir haben das noch nie zuvor gesehen.

03:29.360 --> 03:32.050
Aber es sagt:Wie lange ist die Liste?

03:32.060 --> 03:40.350
In diesem Fall "1, 2, 3, 4, 5". Also ist '0' größer als (* weniger als) '5'.

03:40.530 --> 03:44.040
Wenn das der Fall ist, dann führe diese Schleife aus.

03:44.280 --> 03:51.800
Und wenn du fertig bist, tu 'i ++', was "ich" plus "1" bedeutet.

03:51.820 --> 03:53.620
Also lass uns das durchgehen.

03:53.620 --> 04:06.760
Zuerst "todos.lenth". wenn ich gehe, wenn ich das kopiere, dann mache ich 'todos.length' - ich bekomme '5', fünf Gegenstände.

04:06.870 --> 04:07.940
Das kann ich auch

04:08.070 --> 04:14.060
"Hölle" "Länge" und ich bekomme "8".

04:14.070 --> 04:22.730
Also 1, 2, 3, 4, 5, 6, 7, 8. So sagt 'Länge' nur, wie viele Elemente in der Liste sind.

04:22.720 --> 04:26.390
Und wenn ich Variable mache, ist 'i' gleich '0'.

04:27.620 --> 04:28.700
Nun, 'ich' ist '0'.

04:28.710 --> 04:39.700
Aber wenn ich 'i ++' mache und ich 'i' wieder ansehe, sehe ich, dass es '1' ist. Wenn ich wieder 'i ++' mache, dann bekomme ich '2'.

04:39.740 --> 04:43.010
Das erhöht also 'ich'.

04:43.100 --> 04:48.850
Also was wir tun, ist zu sagen:Beginne mit '0' und solange 'i'

04:48.890 --> 04:54.120
ist kleiner als '5', dann laufe in diesem Block überhaupt ab.

04:54.140 --> 04:57.880
Und wenn du damit fertig bist, füge '1' zu 'i' hinzu.

04:57.950 --> 05:01.980
Lass uns sehen, was passiert, wenn ich 'console.log' mache.

05:02.390 --> 05:10.130
'ich hier. Lass uns speichern und aktualisieren. 0, 1, 2, 3, 4.

05:10.320 --> 05:13.570
Wir machen also eine Schleife, bei der es mit "0" beginnt.

05:13.740 --> 05:15.370
Dann fügen wir '1' hinzu.

05:15.450 --> 05:21.990
Es ist jetzt "1". Dann fügen wir eine weitere "1" zu "2", eine weitere "1" zu "3" und eine weitere "1" zu "4" hinzu und wie kommt es

05:21.990 --> 05:31.890
wir haben hier nicht '5', denn sobald 'i' gleich '5' ist, wird das mit der 'todos.length' übereinstimmen und die Schleife stoppt.

05:31.920 --> 05:36.780
So sagen wir der Schleife, dass wir aufhören sollen. OK.

05:36.990 --> 05:44.290
Also, wie können wir das tun:wenn wir am Ende ein Ausrufezeichen hinzufügen wollten?

05:44.310 --> 05:47.250
Nun, wir können auf "Todos" zugreifen

05:50.430 --> 05:58.840
von - weil es ein Array ist, von 'i'. Weil die ersten herumgehen, wird "i" "0" sein, was "sauberer Raum" sein sollte.

05:58.920 --> 06:05.550
Dann "1", was "Zähne putzen" ist, dann "2", was "Übung" ist, "3", was "javascript lernen" und 4 welche

06:05.550 --> 06:07.420
ist "gesund essen".

06:07.540 --> 06:14.620
Also, lassen Sie uns das überprüfen. Wenn ich 'Todos' mache und spare. Aktualisieren und ich sollte das wieder auf "i" ändern.

06:14.670 --> 06:16.220
Da gehst du.

06:16.310 --> 06:25.220
Sonst, wenn ich das tue, wird das tatsächlich nicht laufen, sieh dir das an. Denn, nun, das ist "5" gleich "5", also ist es

06:25.220 --> 06:27.570
niemals gehen, es wird nie durchgehen.

06:27.770 --> 06:29.090
Also lass uns das wieder auf "ich" ändern.

06:29.210 --> 06:34.290
Und erfrischen:"Reinraum", "Zähne putzen", "Sport treiben", "JavaScript lernen", "gesund essen".

06:34.310 --> 06:35.050
Perfekt.

06:35.060 --> 06:41.840
Also, jetzt kann ich einfach '[i] +'! ''

06:42.220 --> 06:45.850
Lass uns auffrischen. Sieh dir das an!

06:46.090 --> 06:47.630
So wichtig sind diese Gegenstände.

06:47.740 --> 06:59.740
Aber wenn ich 'todo' oder 'todos' mache. Nun, meine "Todos" haben eigentlich nicht dieses Ausrufezeichen, das wir nur an der Konsole angemeldet haben

06:59.740 --> 07:02.990
sie, aber wir haben dieses "todo" eigentlich nicht geändert, richtig?

07:03.190 --> 07:06.800
Also lass uns das tun.

07:06.970 --> 07:22.090
Wir können jetzt sagen:Todos [i] = todos [i] +!

07:22.110 --> 07:23.020
Also lass uns sehen.

07:23.020 --> 07:24.570
Ich erfrische mich.

07:24.570 --> 07:25.330
Nichts passiert.

07:25.330 --> 07:26.760
Aber jetzt, wenn ich "Todos" überprüfe ...

07:29.490 --> 07:33.540
Sieh dir das an! Ich habe Ausrufezeichen in jedem meiner 'Todos'.

07:34.140 --> 07:45.620
Und wieder, um das zu brechen, sagen wir "Reinraum" ist jetzt "Reinraum" plus Ausrufezeichen.

07:45.620 --> 07:46.620
Sehr cool.

07:47.060 --> 07:47.580
OK.

07:47.720 --> 07:51.060
Lassen Sie uns ein paar andere lernen - eigentlich bevor wir es tun,

07:51.290 --> 07:57.620
Was, wenn wir diese von der Liste streichen wollen. Vielleicht wollen wir sie durchkreuzen, weil wir sie gemacht haben. Gut,

07:58.130 --> 08:01.460
wir können etwas wie 'Todos [i] .pop' machen.

08:01.490 --> 08:06.140
Wenn Sie sich erinnern, das ist eine Array-Methode 'Pop', die das letzte Element entfernt.

08:06.350 --> 08:14.870
Also, wenn ich gehe, speichere und aktualisiere, bekomme ich 'todos [i] .pop ist keine Funktion'.

08:14.870 --> 08:15.540
Warum das?

08:15.560 --> 08:20.070
Nun, weil wir sagen "Reinraum" - "Pop".

08:20.100 --> 08:21.820
Und das ist eine 'Zeichenfolge'.

08:22.290 --> 08:27.990
Was wir machen wollen ist 'todos.pop', denn das ist das 'Array'.

08:28.350 --> 08:34.230
Also, wenn ich das speichere und auffrische, lass uns sehen, was wir in unseren "Todos" haben:08:35.880 --> 08:38.920
"Reinraum" und "Zähne putzen".

08:38.930 --> 08:39.510
Hmm.

08:39.630 --> 08:40.740
Warum das?

08:41.160 --> 08:46.820
Nun, anfangs war das "0".

08:47.060 --> 08:50.290
Und "Todos" Listenlänge war "5".

08:50.600 --> 08:59.770
Aber dann, weil wir es platzierten, änderte sich das zu "4" und das zu "eins" und dann "3" und "2".

09:00.050 --> 09:05.910
Also, wie Sie sehen können, entfernten wir "essen gesund", "studieren Sie Javascript" und "trainieren Sie".

09:05.930 --> 09:12.270
Aber weil sich unsere "Todos" -Länge geändert hat, hat sie auf halbem Wege aufgehört.

09:12.310 --> 09:16.080
Also, wie können wir dieses Problem beheben?

09:17.630 --> 09:29.360
Nun, wir können die Variable 'todos.length' gleich 'todos.length' machen.

09:29.650 --> 09:32.020
Also jetzt ist diese Variable '5'.

09:32.140 --> 09:42.680
Also, wenn ich nur Variable 'todos.lenth' mache - das wird sich merken, weil es nur noch laufen wird

09:42.680 --> 09:43.580
einmal, es wird ...

09:43.730 --> 09:48.370
Das wird laufen, dann werden wir 'Todos.length' '5' zuweisen.

09:48.560 --> 09:51.370
Und dann wird sich das wiederholen.

09:51.400 --> 09:59.940
Wenn ich das also speichere und auffrische, schauen wir uns 'todos' an. Sieh dir das an! Wir haben alle unsere "Todos" beendet!

10:00.070 --> 10:00.790
Sehr cool.

10:01.430 --> 10:11.230
Nun, lassen Sie mich Ihnen eine andere Option zeigen, die "while" -Schleife. Die "while" -Schleife geht ungefähr so.

10:15.250 --> 10:18.810
'while', - erstellen wir hier eine Variable. Variable 'Zähler'

10:21.390 --> 10:22.910
"Gegenstück"

10:23.090 --> 10:36.160
Wir werden das sagen, das ist "0". Und wir werden sagen:"while counterOne ist weniger als 10".

10:36.300 --> 10:39.810
In diesem Fall möchte ich 'console.log'

10:43.000 --> 10:50.590
"Gegenstück". Und dann möchte ich 'counterOne' plus, plus.

10:50.640 --> 10:53.010
Denken Sie daran, wir tun, wir fügen hinzu.

10:53.430 --> 10:58.800
Also jedes Mal, wenn wir "Zähler" um "1" erhöhen. Lass uns sehen, was hier passiert.

10:58.800 --> 11:09.330
Wenn ich das speichere und auffrische:"0, 1, 2, 3, 4, 5, 6, 7, 8, 9" und dann stoppt es, denn, sobald es "10" ist,

11:10.330 --> 11:11.500
Das ist nicht mehr richtig.

11:11.500 --> 11:14.530
Also dieser Teil des Blocks läuft nicht.

11:17.820 --> 11:18.260
OK.

11:18.420 --> 11:29.200
Kann ich etwas tun ... vielleicht ... umgekehrt? Wo wir sagen, dass der "Counter" ist "10" und dieses Mal wollen wir

11:29.200 --> 11:30.180
herunterzählen.

11:30.520 --> 11:38.940
Also, während der Zähler '10' ist - mach weiter, und ansonsten - hör auf. Und so wie wir das machen, wollen wir natürlich

11:39.210 --> 11:39.780
subtrahieren.

11:39.780 --> 11:43.900
Wir wollen nicht weiter "11" oder "12" fahren, weil es sonst für immer weitergeht.

11:44.070 --> 11:47.570
Die Art, wie wir das tun, ist - minus, minus, was genau das Gegenteil ist.

11:47.580 --> 11:49.190
Es subtrahiert also '1'.

11:49.620 --> 11:50.810
Mal sehen was passiert.

11:52.610 --> 11:56.410
'10, 9, 8, 7, 6, 5, 4, 3, 2, 1 '.

11:56.420 --> 11:57.830
Da gehst du.

11:57.890 --> 12:05.300
Nun, aus Neugierde, was passiert, wenn ich so weitermache, wo die Zahl immer weiter steigt

12:05.330 --> 12:08.560
'10' bis '11', zu, nun, unendlich.

12:08.590 --> 12:08.890
Recht?

12:08.900 --> 12:16.800
Es wird einfach weitergehen und - Sie können dies in Google Chrome tun, wenn Sie möchten.

12:16.880 --> 12:19.950
Es ist wirklich ziemlich unterhaltsam.

12:19.970 --> 12:27.170
Was passiert ist - es geht einfach immer weiter. Sie bekommen nur eine Liste all dieser Dinge und

12:27.260 --> 12:34.460
es heißt das in einer "Endlosschleife". Eine Endlosschleife bedeutet, dass es unendlich oft geht. Außer es

12:34.460 --> 12:38.910
nicht wirklich, denn irgendwann wird Google Chrome abstürzen.

12:38.990 --> 12:42.440
Es wird sagen:"Hey, ich kann nicht mit all diesen Informationen umgehen.

12:42.440 --> 12:45.630
Du machst mich verrückt. "Und es wird aufhören zu arbeiten.

12:46.640 --> 12:47.040
OK.

12:47.120 --> 12:49.930
Also lernten wir die "for-Schleife".

12:50.060 --> 12:52.700
Wir haben die "Weile" gelernt. Was haben wir sonst noch?

12:52.700 --> 12:55.630
Wir haben das 'tun'.

12:55.790 --> 13:07.470
Also, das ist die "Do while" -Schleife und es ist ein bisschen anders "the while". Wir beginnen mit "do".

13:07.750 --> 13:19.070
Dann geschweifte Klammern, und wir sagen 'counter' ... nennen wir diesmal 'counterTwo'. Ich werde Variable 'counterTwo' tun

13:19.910 --> 13:25.860
entspricht '10'. Und tun 'counterTwo' plus plus.

13:25.930 --> 13:27.180
Fügen Sie also 'counterTwo' hinzu.

13:27.640 --> 13:32.850
Und auch 'console.log (counter Two)'.

13:33.130 --> 13:41.440
Und wir wollen 'console.log' ganz oben verschieben, denn auf diese Weise fange ich mit '10' an, dann erhöhe - oops ...

13:41.490 --> 13:43.450
Dies sollte subtrahiert werden.

13:43.530 --> 13:45.700
Also machen wir '10'.

13:45.790 --> 13:49.710
Es ist ungefähr wie "10", dann wird es subtrahieren. Wenn es also das nächste Mal hier ist, wird es passieren

13:49.710 --> 13:50.980
sei '9'.

13:51.480 --> 13:55.650
Und dann machen wir 'während' und wir geben hier eine Bedingung.

13:55.650 --> 14:04.890
Also werden die Bedingungen 'counterTwo' sein, es wird größer als '0' sein.

14:05.240 --> 14:05.520
OK.

14:05.530 --> 14:08.910
Lass uns sehen, was hier passiert.

14:08.990 --> 14:13.960
Ich aktualisiere:'10, 9, 8, 7, 6, 5, 4, 3, 2, 1 '.

14:14.310 --> 14:21.580
Hmmm, es sieht so aus, als hätten wir genau das gleiche wie die While-Schleife gemacht, nicht wahr?

14:21.580 --> 14:24.060
Lass mich das einfach testen.

14:24.070 --> 14:27.240
Lass uns hier auffrischen.

14:27.470 --> 14:35.120
Und wir sehen, dass wir '10' bis '1' für die while-Schleife und '10' bis '1' bis zur 'do while'-Schleife haben.

14:35.120 --> 14:37.490
Was ist der Unterschied hier?

14:37.760 --> 14:44.930
Der Unterschied ist, dass wir mit einer "while" -Schleife zuerst den Zustand prüfen, also sagen wir:"Ist counterOne größer?

14:44.930 --> 14:45.500
als '0'?

14:45.550 --> 14:53.960
OK. Dann tu das Zeug. "Im Gegensatz zu der" do while "-Schleife, die besagt:" Mach das Zeug zuerst und dann mach 'counterTwo'. "

14:54.110 --> 14:57.500
Lassen Sie mich diesen Punkt demonstrieren.

14:57.570 --> 15:07.530
Wenn wir ... '10' hier machen. Und '10'. Lass uns auffrischen.

15:07.750 --> 15:09.200
Ich bekomme nur '1'.

15:09.210 --> 15:11.430
Hmm ... Lass uns hier etwas überprüfen.

15:11.510 --> 15:24.330
Ich werde sagen, dass dies die "while" -Schleife ist und dies die "do while" -Schleife ist. Speichern und aktualisieren. So sieht es aus

15:24.330 --> 15:26.530
Die 'Do While' lief.

15:26.910 --> 15:32.520
Aber die 'while' Schleife hat es nie getan, weil. Nun, "10" entspricht "10".

15:32.700 --> 15:40.770
Dies schlägt fehl und die Schleife wird nicht ausgeführt. Im Gegensatz zur "do while" -Schleife tut dies das zuerst und überprüft dann die

15:40.770 --> 15:42.670
Bedingung, wenn sie Schleife sollten.

15:42.810 --> 15:51.180
Das ist der Unterschied zwischen diesen beiden. Aber um ehrlich zu sein, die meiste Zeit wirst du gehen

15:51.180 --> 16:00.530
Verwenden Sie eine "for" -Schleife. Und an die "for" -Schleife gewöhnt man sich. Aber es gibt tatsächlich ein besseres

16:00.530 --> 16:02.530
Art und Weise es zu tun.

16:02.720 --> 16:08.990
Wenn Sie sich die 'SectionOutline' ansehen, sehen Sie, dass ich eine letzte habe, die 'forEach' ist und in 'new in' steht

16:08.990 --> 16:10.590
ECMAScript 5 ".

16:10.880 --> 16:19.070
Wie Sie sich erinnern, entwickelt sich JavaScript ständig weiter und ECMAScript 5 war ein neuer Standard, der hinzugefügt wurde

16:19.230 --> 16:25.170
die forEach-Methode. Also, was ist die ForEach-Methode?

16:25.180 --> 16:29.190
Nun, ich werde Ihnen den Unterschied zwischen einer for-Schleife und einer ForEach-Schleife zeigen.

16:29.190 --> 16:30.920
Beide machen das Gleiche.

16:31.110 --> 16:34.620
Aber sag mir, welcher besser aussieht.

16:34.710 --> 16:42.490
Also, nun, hier werden wir 'console.log (i)' sagen

16:43.640 --> 16:54.010
Also loggen wir nur das 'ich' ein. Und mit einer "forEach" -Schleife kann ich "todos.forEach" -Funktion ausführen

16:55.110 --> 16:58.260
'i', 'console.log (i)'.

16:58.560 --> 17:04.270
Es sieht ein bisschen verwirrend aus, aber lass es einfach ausprobieren, lass uns sehen, was passiert.

17:04.880 --> 17:16.160
Es sieht also so aus, als ob eine Zeile '10' auf '0, 1, 2, 3, 4' gedruckt wird und Zeile '14' 'freien Platz, Pinsel' ausdruckt

17:16.170 --> 17:17.950
Zähne, Übung, Studium von Javascript,

17:17.950 --> 17:19.090
gesund ernähren".

17:19.090 --> 17:20.480
Was machen wir hier?

17:20.480 --> 17:22.220
Nun das 'forEach'

17:22.430 --> 17:24.190
Es braucht ein Array.

17:24.190 --> 17:31.530
In diesem Fall die "Todos", und es fragt nach einem Argument, das ist "sag mir, was ich damit machen soll".

17:33.030 --> 17:41.820
Die Aktion, die wir an den Todos ausführen wollen, kann also in einer Funktion dargestellt werden.

17:41.870 --> 17:52.330
Also sage ich "Funktion", und diese Funktion erhält das Argument von "i", das heißt jedes einzelne Element in

17:52.330 --> 17:53.170
die "Todos".

17:53.530 --> 18:02.750
Also könnte ich nur 'todo' hier und 'todo' sagen. Und erfrischen und es wird immer noch das selbe sein.

18:02.770 --> 18:12.030
Sie sehen also hier, dass wir nicht unbedingt auf den Index zugreifen müssen, wie wir es bei diesem hier tun

18:12.030 --> 18:21.600
Um die "Todos" zu bekommen, musste ich "Todos [i]" machen. Wenn ich auffrische. OK.

18:21.710 --> 18:24.440
In diesem Fall ist es jetzt egal.

18:24.910 --> 18:29.190
OK, aber wie greife ich auf den Index innerhalb von 'forEach' zu?

18:29.570 --> 18:38.860
Nun, der zweite Parameter. Und das zweite Argument, das es erhält, ist das "i", der Index.

18:38.870 --> 18:52.260
Also, wenn ich 'ich' mache und auffrische:'0, 1, 2, 3, 4'. Es ist also die gleiche Sache, die das in der 'for' Schleife macht. Und ich erfrische mich

18:52.980 --> 19:03.710
und sieh dir das an. Nun, indem du dir diese 2 anschaust, welche erzählt dir mehr darüber, was es macht?

19:04.850 --> 19:06.670
Dieser oder dieser?

19:06.710 --> 19:17.490
Lassen Sie uns es auf Englisch lesen:'todos.forEach' führen Sie eine Funktion aus, die 'Konsole protokolliert' das 'Todo' und den 'Index'

19:18.520 --> 19:19.720
Gegen

19:20.130 --> 19:22.520
Nun, ehrlich gesagt, das sieht verwirrend aus.

19:23.460 --> 19:28.860
"ForEach" ist also eine wirklich großartige Methode, die sie der Sprache hinzugefügt haben, was sie wirklich vereinfacht

19:28.860 --> 19:29.700
Dinge.

19:29.700 --> 19:31.930
Die meisten Leute könnten durch diesen Teil verwirrt werden

19:31.920 --> 19:37.610
die Funktion. Aber wir wollen Ihnen nur zeigen, wie kraftvoll 'forEach' ist, wir können das tatsächlich tun.

19:37.650 --> 19:45.760
Ich werde die Funktion ausschalten, und ich werde es "logTodos" nennen.

19:46.010 --> 19:59.390
Und jetzt muss ich nur noch - eine Funktion haben und sie 'logTodos' nennen.

19:59.570 --> 20:02.340
Und jetzt werde ich das kommentieren.

20:02.630 --> 20:09.330
Es wird genau dasselbe tun, aber ich kann jetzt "logTodos" an anderen Orten verwenden.

20:10.260 --> 20:23.300
Also, ich kann jetzt - sagen wir, ich habe eine andere Liste, die vielleicht Ausrufezeichen hat, wie wir es in der ersten getan haben.

20:26.340 --> 20:28.760
"todosWichtig".

20:30.780 --> 20:44.810
So, jetzt kann ich 'todosImportant.forEach' und benutze die gleiche Funktion 'logTodos'. Ich speichere und aktualisiere. Und schau

20:44.810 --> 20:47.700
dabei! Wir haben diese auch zu verwenden.

20:47.740 --> 20:51.280
Sie können also sehen, dass es sehr erweiterbar ist.

20:51.300 --> 20:56.830
Die einzige Einschränkung, die ich Ihnen mit 'forEach' zeigen möchte, ist, dass es ein neuer Standard ist.

20:56.910 --> 21:01.590
Wie bei allen neuen Standards sollten wir überprüfen, ob sie in allen Browsern funktionieren.

21:01.590 --> 21:08.070
Also, wenn Sie sich erinnern, hatten wir "caniuse.com", das wir dafür verwenden. Und wir verwenden es bei CSS, um sicherzustellen, dass

21:08.100 --> 21:15.390
dass unsere CSS3-Funktionen wie "Boxshadow" und "Transitions" auf allen Browsern funktionieren.

21:15.420 --> 21:23.410
Also lass uns das tun. Lass uns Foreach machen und du siehst hier 'ECMAScript5' - 'foreach'.

21:23.600 --> 21:27.500
Es sieht aus wie, nun, volle Unterstützung!

21:27.770 --> 21:29.160
Alles sieht gut aus.

21:29.420 --> 21:33.840
Wir haben nur Opera Mini, das teilweise Unterstützung hat.

21:33.980 --> 21:41.460
Es sieht also ziemlich gut aus. Es sei denn, wir machen uns wirklich Sorgen wegen Opera Mini. Wir können 'foreach' im Browser verwenden.

21:41.530 --> 21:54.460
Und nur um zu testen, ob wir unsere Konsole öffnen, können wir definitiv sehen, dass ein Array forEach hat.

21:54.540 --> 21:56.920
So, da hast du es.

21:57.060 --> 22:07.630
Wir hatten die for-Schleife, die while-Schleife, die while-Schleife und schließlich forEach. Und das nächste Video, das wir sind

22:07.630 --> 22:14.320
Wir werden unser Facebook-Beispiel erweitern und mehrere Nutzer haben. So können wir die Datenbank durchlaufen

22:14.410 --> 22:19.830
von mehreren Benutzern und sehen, ob der 'Benutzername' und 'Passwort' mit irgendwelchen übereinstimmen.

22:20.080 --> 22:21.640
Wir sehen uns im nächsten. Tschüss

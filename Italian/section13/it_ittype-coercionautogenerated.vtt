WEBVTT

00:01.850 --> 00:03.660
Digita coercizione.

00:03.890 --> 00:09.940
Se c'è una cosa che ti farà strappare tutti i capelli per la frustrazione.

00:10.150 --> 00:19.290
Fai attenzione se digiti Google in origine in JavaScript e guardi alcuni dei post che vedrai molte persone arrabbiate

00:19.290 --> 00:26.310
con alcune delle cose funky che JavaScript fa e ne parleremo e io sono ti

00:26.310 --> 00:32.700
darò solo una breve panoramica perché diventa davvero complicato ed è qualcosa che

00:32.730 --> 00:39.390
dovresti capire e sapere di cosa si tratta ma non devi conoscere ogni singolo

00:39.510 --> 00:43.630
dettaglio perché la maggior parte delle parti difficili.

00:43.680 --> 00:48.060
Beh, non dovresti usarlo nel tuo codice perché è confuso.

00:48.060 --> 00:50.500
Quindi qual è la causa del tipo.

00:51.620 --> 00:59.620
È qualcosa come questo uguale a due stringhe e che equivale a due.

00:59.690 --> 01:08.000
È vero che attenzione al tipo significa che quando l'aspetto che è le cose a

01:08.510 --> 01:13.070
sinistra ea destra dell'operatore sono tipi diversi.

01:13.120 --> 01:22.150
Che non è un tipo di stringa finale, uno di essi verrà convertito in un valore equivalente dal motore JavaScript.

01:22.990 --> 01:27.740
Quindi il motore JavaScript dirà 1 equivale alla stringa 1.

01:27.940 --> 01:29.890
Penso che tu intenda il numero uno.

01:29.890 --> 01:39.550
Quindi lo farà per noi e confronterà il numero uno con il numero uno ora in base alla definizione del

01:39.640 --> 01:47.100
tipo di attenzione. Attenzione: la lingua che converte un certo tipo in un altro tipo.

01:47.150 --> 01:55.460
Lascia che ti faccia una domanda: tutte le lingue hanno cautela.

01:55.490 --> 01:58.900
Cosa ne pensi sì, lo fanno.

01:59.470 --> 02:07.230
Perché abbiamo sempre bisogno di convertire i tipi tra i programmi per fare cose in memoria.

02:07.290 --> 02:12.240
Tipi diversi sembrano completamente diversi da quelli che scriviamo.

02:12.250 --> 02:16.290
Scrivi il numero cinque nella memoria fisica effettiva.

02:16.290 --> 02:23.070
Oh, il mio computer è rappresentato una volta in zero e tutte le lingue lo fanno.

02:23.070 --> 02:29.110
Quindi c'è una sorta di cautela di tipo a diversi livelli dello stack.

02:29.430 --> 02:37.650
Accade semplicemente che JavaScript abbia una causa di tipo particolarmente pesante in natura perché è di tipo dinamico ed

02:37.650 --> 02:40.460
è per questo che lo fa.

02:40.500 --> 02:50.170
Torniamo all'esempio nel tipo JavaScript, la cautela si verifica quando si utilizza il doppio doppio doppio segno uguale significa

02:50.170 --> 02:59.410
semplicemente confrontare i due valori e se hanno tipi diversi provare a forzare bene uno nello stesso

02:59.920 --> 03:00.790
tipo.

03:02.330 --> 03:13.880
Se torniamo indietro e facciamo una stringa qui e io faccio tre uguali e corro divento falso perché tre uguali in JavaScript

03:13.940 --> 03:17.180
significa confrontare con i valori.

03:17.360 --> 03:25.300
Ma non cercare di maledire i valori in modo esplicito con il tuo confronto e fai esattamente quello che ti dico.

03:25.470 --> 03:32.000
Quindi c'è mai un tempo in cui dovresti usare solo due uguali invece di tre uguali.

03:32.160 --> 03:33.340
Mm hmm

03:33.510 --> 03:34.410
Lo dirò.

03:34.410 --> 03:35.970
No non c'è.

03:36.000 --> 03:43.930
Alcune persone potrebbero sostenere che il doppio uguale può effettivamente avere alcune applicazioni interessanti in cui forziamo

03:44.010 --> 03:51.890
qualcosa e facciamo una sorta di controllo molto rapidamente ma non è un codice prevedibile giusto.

03:51.900 --> 03:53.000
Può essere fonte di confusione.

03:53.040 --> 04:00.100
Potrebbe davvero essere un gotcha e ingannare alcune persone, quindi usa sempre tre uguali invece di due.

04:00.300 --> 04:04.590
Ora la cautela del tipo non accade solo con il segno di uguale.

04:04.590 --> 04:06.870
Puoi anche fare un'istruzione if.

04:07.020 --> 04:19.930
Quindi, se uno poi restituisce cinque e se corro così bene, non c'è alcuna funzione qui per console.

04:21.030 --> 04:22.900
Ho registrato per una lunga giornata oggi, giusto.

04:22.910 --> 04:24.560
Quindi dammi una pausa a tutti.

04:24.640 --> 04:25.360
Tutto ok.

04:25.530 --> 04:29.540
Se corro questo cinque è registrato.

04:29.580 --> 04:30.450
Perché.

04:30.480 --> 04:35.400
Perché il corso javascript è uguale a vero.

04:35.490 --> 04:36.930
E se faccio zero qui.

04:36.990 --> 04:44.220
Se faccio zero nessun corso javascript è questo e dice bene che voglio booleano qui.

04:44.430 --> 04:53.050
Quindi prenderò il tuo zero e lo trasformerò in un falso ora questo tipo di cautela ci sono molti

04:53.050 --> 04:55.390
dettagli interessanti ad esso.

04:56.260 --> 05:02.470
E in effetti c'è un bel sito Web che ti mostra alcuni dei confronti che

05:02.470 --> 05:04.990
JavaScript fa con tre uguali.

05:04.990 --> 05:08.920
Cioè senza cautela le cose hanno un senso.

05:08.920 --> 05:13.860
Vedi che falso equivale a due falsi e basta.

05:13.910 --> 05:23.070
Puoi vedere che stringa false è solo tripla e restituisce true con stringa false.

05:23.540 --> 05:26.740
Ma se facciamo il doppio equivale bene.

05:27.440 --> 05:27.810
Oh ragazzo.

05:27.830 --> 05:30.790
Questo è solo un casino non è vero.

05:30.800 --> 05:41.210
Ad esempio, la stringa uno è uguale a vera, un array che ne contiene uno è anche vero se confrontato con la

05:41.210 --> 05:42.880
stringa di uno.

05:43.100 --> 05:47.200
E ci sono così tanti piccoli casi strani qui.

05:47.390 --> 05:49.820
Se vuoi giocare con questo, fallo.

05:49.820 --> 05:53.330
Ma mi piacerebbe rimanere con triple uguali.

05:53.360 --> 06:03.260
Puoi anche vedere alcune delle dichiarazioni if qui e alcuni dei casi F che possono davvero essere difficili ora se andiamo a

06:03.380 --> 06:10.550
questa pagina MDMA a cui collegherò in questo video vediamo che abbiamo il doppio uguale al

06:11.090 --> 06:12.410
triplo uguale.

06:12.500 --> 06:20.270
Ma poi anche qualcosa chiamato Object dot è abbastanza nuovo per JavaScript e questo è interessante e molto

06:20.270 --> 06:23.380
probabilmente non lo vedrai molto spesso.

06:23.390 --> 06:24.790
Ma penso sia interessante.

06:24.800 --> 06:31.730
Quindi ne parleremo subito, vedi in JavaScript che esiste un concetto di zero

06:32.360 --> 06:35.120
negativo e più zero.

06:35.120 --> 06:35.850
Strano lo so.

06:36.200 --> 06:48.850
Quindi se faccio zero zero triplo uguale a zero e corro divento vero, ma sono cose tecnicamente diverse in JavaScript,

06:49.030 --> 06:55.180
quindi posso effettivamente fare il punto oggetto e dati i

06:59.190 --> 07:04.190
due parametri ed eseguire e divento falso.

07:04.400 --> 07:12.910
Ora, perché è utile se torniamo a questa pagina vediamo quell'oggetto che funziona praticamente allo stesso modo del

07:12.940 --> 07:16.300
triplo uguale tranne per alcuni casi.

07:16.420 --> 07:19.220
Questo è lo 0 positivo e negativo.

07:19.390 --> 07:29.790
E se scendiamo fino a questo piccolo funky e non un no e possiamo fare un intero corso su quanto sia strano questo

07:29.790 --> 07:39.360
non è un numero ma se non ho fatto un numero che rappresenta non in numeri in JavaScript e faccio triplo

07:39.700 --> 07:46.020
non è uguale a un numero che ottengo falso, ma perché è quello.

07:46.020 --> 07:49.200
Questo dovrebbe essere uguale a destra.

07:49.470 --> 07:54.240
Quindi, se usiamo un oggetto, questo diventa vero.

07:54.240 --> 08:01.470
Ancora una volta molto probabilmente nella tua vita di programmazione quotidiana non incontrerai mai questo problema.

08:01.680 --> 08:09.140
Ma volevo dimostrare per te quanto può essere caotica la cautela di tipo e se sei il tipo di persona che

08:09.140 --> 08:14.860
ama solo la cautela di tipo e vuole leggere tutto su di essa e comprendere tutte

08:14.870 --> 08:22.880
queste complessità che collegherò alle specifiche reali di cui parla come l'algoritmo di confronto di uguaglianza funziona per me se leggo questo sarò

08:22.910 --> 08:26.440
una buona lettura della buona notte per farmi addormentare.

08:26.570 --> 08:28.970
Se ti interessa puoi dare un'occhiata.

08:28.970 --> 08:36.980
Il principale takeaway da qui è che dovresti usare triple uguali perché la cautela del tipo in

08:37.220 --> 08:39.780
JavaScript può essere davvero complicata.

08:39.970 --> 08:46.090
A proposito, come una piccola nota divertente c'è una cattura dello schermo che ho preso da Netflix

08:46.270 --> 08:51.650
guardando questo fantastico documentario esilarante e vedi che i bug nel codice sono inevitabili.

08:51.730 --> 08:58.300
Anche il potente Netflix ogni tanto ha un problema da qualche parte non un numero.

08:58.300 --> 08:58.670
Tutto ok.

08:58.870 --> 08:59.760
Per ora è tutto.

08:59.800 --> 09:01.230
Vedo nel prossimo di.

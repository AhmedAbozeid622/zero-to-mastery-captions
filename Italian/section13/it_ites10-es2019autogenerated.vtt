WEBVTT

00:01.230 --> 00:02.620
Ciao a tutti.

00:02.700 --> 00:09.090
Ora siamo pronti per Sì 10 o Xmas script 20 19.

00:09.120 --> 00:09.900
Giusto.

00:09.900 --> 00:10.620
Ogni anno.

00:10.650 --> 00:14.460
Stanno costantemente cercando di migliorare la lingua e questo è javascript.

00:14.460 --> 00:18.370
E ora ESPN è l'ultimo.

00:18.410 --> 00:23.750
Quindi quali nuove funzionalità otteniamo in questa nuova versione di JavaScript.

00:24.650 --> 00:27.890
Bene per fortuna non ce ne sono troppi.

00:27.920 --> 00:38.290
Quindi cominciamo con il mio preferito e si chiama flat and flat è un metodo che possiamo usare

00:38.530 --> 00:40.610
in una gara.

00:40.640 --> 00:50.470
Lascia che ti mostri cosa intendo, diciamo che ho una variabile array che contiene un array molto eccitante

00:50.470 --> 00:57.640
di 1 2 3 4 5 se ora eseguo array dot flat.

00:57.680 --> 01:02.050
Copiamo questo codice ed eseguilo qui.

01:02.100 --> 01:03.570
Cosa pensi che succederà.

01:04.140 --> 01:09.400
Beh, assolutamente nulla, torniamo a un nuovo array.

01:09.420 --> 01:17.540
Sembra ma sembra esattamente lo stesso, ma è qui che Flight diventa eccitante.

01:17.550 --> 01:20.350
Immagina se questo avesse matrici nidificate.

01:20.430 --> 01:29.190
Quindi, ad esempio, due e tre in cui è presente un array e quindi quattro e cinque erano anche un array nidificato all'interno di

01:29.190 --> 01:30.950
un array più grande.

01:31.170 --> 01:36.900
Se ora copio questo e chiamiamo questo array per scoprirlo.

01:36.930 --> 01:42.330
Copia questo e incollato qui Ehi, dai un'occhiata.

01:42.530 --> 01:46.160
Otteniamo un nuovo array appiattito.

01:46.340 --> 01:50.700
Cioè non ci sono più matrici nidificate.

01:50.920 --> 01:58.040
Va bene, allora andiamo avanti e cosa succede se abbiamo l'array 3 e l'array 3

01:58.190 --> 02:09.570
è ancora più nidificato di quello che avevamo prima diciamo che ne abbiamo uno due tre come questo e quindi forse ne avremo uno

02:10.230 --> 02:14.270
cinque ben annidato abbastanza profondo come quella.

02:14.310 --> 02:21.450
Quindi ora abbiamo un array c'è un altro array e al suo interno c'è un altro array.

02:21.510 --> 02:23.110
Cosa pensi che succederà qui.

02:23.410 --> 02:27.360
Vuoi copiare e incollare eseguire questo codice.

02:27.380 --> 02:28.420
Tutto ok.

02:28.580 --> 02:36.550
Quindi ho un nuovo array indietro ma vediamo che in realtà non esiste un array completamente piatto.

02:36.560 --> 02:44.970
Invece ne abbiamo uno due tre quattro, ma poi cinque è stato solo appiattito di un livello,

02:45.150 --> 02:48.370
quindi essenzialmente rimosso solo queste parentesi.

02:48.380 --> 02:54.470
Ora la cosa interessante con flat è che possiamo dire quanti layer volare nell'array.

02:54.620 --> 02:59.590
Quindi, se torniamo al nostro esempio e qui il valore predefinito era 1.

02:59.660 --> 03:01.370
Ma se cambiamo questo

03:04.260 --> 03:13.220
in due ora copia e incolla andiamo ad aggiornare ed eseguirlo di nuovo per vedere che abbiamo un array completamente appiattito.

03:13.800 --> 03:20.680
Quindi qui posso dire quante volte voglio volare o quanti strati voglio volare nell'array.

03:20.750 --> 03:20.990
Tutto ok.

03:21.000 --> 03:23.580
Ma ho un esempio davvero eccitante per te.

03:23.580 --> 03:25.620
Preparati per questo.

03:25.650 --> 03:30.510
Congratulazioni, sei appena diventato il proprietario di Jurassic Park.

03:30.510 --> 03:39.600
Hai un parco con tutte queste antiche creature e il re qui è estremamente pericoloso.

03:39.600 --> 03:40.180
Ecco perchè.

03:40.200 --> 03:48.090
Beh, è nella sua area contenuta del parco con molte barricate intorno perché non vogliamo che

03:48.090 --> 03:50.090
il rex si scateni.

03:50.190 --> 03:52.710
Ma ecco il problema.

03:52.790 --> 03:55.190
Sei un cattivo ragazzo a Jurassic Park.

03:55.190 --> 04:02.610
Se ti chiedessi hey come puoi estendere completamente questo array come faresti per farlo.

04:03.570 --> 04:04.560
Metti in pausa il video.

04:04.560 --> 04:05.400
Pensaci.

04:05.400 --> 04:07.070
Pronto per la risposta

04:07.080 --> 04:16.980
Bene, possiamo fare il punto di Jurassic Park in modo piatto e quindi potresti voler davvero contare quanti array sono

04:16.980 --> 04:20.730
nidificati qui ma c'è un trucco qui.

04:21.830 --> 04:31.870
Potrei forse fare solo 50 vediamo cosa succede se copio questo rendiamolo un po 'più grande.

04:31.990 --> 04:33.480
Mi aggiorno qui.

04:33.580 --> 04:35.190
Copia e incolla questo.

04:35.230 --> 04:36.930
Vediamo cosa succede.

04:37.060 --> 04:40.940
E Jurassic Park dovrebbe essere Jurassic Park.

04:40.960 --> 04:42.430
Copiamolo di nuovo.

04:42.460 --> 04:46.060
Rinfresciamo.

04:46.090 --> 04:47.070
Tutto ok.

04:47.170 --> 04:52.220
Tutte le barricate sono a terra e gli animali si stanno scatenando.

04:52.370 --> 04:56.800
E ho scelto casualmente 50 perché sapevo che 50 non lo erano.

04:56.870 --> 05:02.720
Bene, quanti array nidificati abbiamo ora nell'esercizio dopo questo video.

05:02.860 --> 05:10.600
Ti mostrerò un piccolo trucco per assicurarti di poter finanziare il massimo livello, ma è

05:10.600 --> 05:11.680
per l'esercizio.

05:11.720 --> 05:20.440
Un'altra cosa davvero utile che puoi fare con flat è supponiamo che tu riceva un sacco di voci e

05:20.440 --> 05:30.130
queste voci dai tuoi utenti entrino e forse riceviamo Bob, facciamo in modo che Sally inserisca il loro nome ma poi

05:30.130 --> 05:38.440
anche un sacco di voci che sono completamente vuoto con forse Cindy alla fine qui usando flat.

05:38.440 --> 05:47.870
Possiamo effettivamente offline le voci e ripulire i nostri dati, quindi posso dire che le voci sono piatte in questo modo.

05:48.100 --> 05:58.000
E se copio e incollo questo aspetto, pulisce i dati per me, il che è davvero bello.

05:58.070 --> 05:58.550
Tutto ok.

05:58.550 --> 06:10.980
La prossima caratteristica di ESPN è la mappa piatta e la mappa piatta, come suggerisce il nome, ci consente di utilizzare una funzione piatta e

06:11.910 --> 06:17.280
la funzione o il metodo della mappa su un array.

06:17.370 --> 06:19.680
Quindi facciamo qualcosa di divertente qui.

06:19.740 --> 06:25.100
Diciamo che abbiamo di nuovo Jurassic Park e questa volta useremo la mappa piatta.

06:25.140 --> 06:32.220
Quindi diciamo Jurassic Park e chiameremo questa nuova variabile.

06:32.290 --> 06:33.650
Facciamo concetto.

06:33.800 --> 06:35.210
Jurassic Park.

06:35.420 --> 06:40.020
Il caos e questo caos avranno.

06:40.020 --> 06:44.230
Mentre l'array Jurassic Park che avevamo sopra.

06:44.270 --> 06:46.160
Rendiamolo un po 'più grande.

06:46.370 --> 06:49.730
E ora possiamo usare una mappa piatta per fare qualcosa di interessante.

06:51.110 --> 07:01.670
Posso dire che per ogni oggetto che ci divertiremo otterremo una creatura e questa creatura che usa le

07:01.670 --> 07:06.730
funzioni freccia otterrà una creatura più il T-Rex.

07:06.740 --> 07:10.310
Quindi copierò il T-Rex qui.

07:10.430 --> 07:16.910
Quindi ogni creatura otterrà un T-Rex come vicino che non va bene.

07:16.910 --> 07:23.840
Saranno tutti mangiati dal T-Rex è il T-Rex che non possono carnivore Non sono sicuro che dovrai farlo

07:23.840 --> 07:24.850
da solo.

07:25.240 --> 07:25.760
Tutto ok.

07:25.820 --> 07:36.710
Quindi abbiamo la mappa piatta di Jurassic Park, quindi sto appiattendo Jurassic Park e quindi mappando su questo array appiattito e

07:36.840 --> 07:42.170
facendo una sorta di funzione di mappa su di esso.

07:42.920 --> 07:53.230
Quindi vediamo cosa succede se ora copio questo e lo incollo se ora controllo cos'è il caos di Jurassic Park e

07:53.410 --> 08:04.680
premo Invio oh ragazzo guarda che abbiamo vicini vicini con tutte le creature e mentre è caos assoluto e giurassico Parcheggia la mappa piatta

08:04.740 --> 08:11.940
ci consente di utilizzare la funzione di base della mappa e quindi appiattisce il risultato

08:12.030 --> 08:14.980
a una profondità di una.

08:15.000 --> 08:16.500
Va bene, andiamo avanti.

08:16.590 --> 08:19.030
Il prossimo è molto semplice.

08:19.050 --> 08:22.970
Supponiamo che tu riceva un'e-mail dell'utente e un'e-mail dell'utente.

08:22.980 --> 08:29.880
Bene, viene inserito un po 'in modo errato, quindi otteniamo un sacco di spazi

08:30.000 --> 08:39.200
e quindi abbiamo Eddie the Eagle su gmail dot com che riceviamo dall'utente o forse abbiamo anche e-mail dell'utente.

08:39.660 --> 08:50.610
E questa volta Johnny Dangerous a G. M. punto com inserisce le loro informazioni ma abbiamo di

08:50.610 --> 08:52.580
nuovo degli spazi vuoti.

08:52.690 --> 08:53.930
Cosa possiamo fare.

08:53.980 --> 09:04.890
Bene con la nuova funzionalità di iOS 10 possiamo semplicemente dire che il punto e-mail dell'utente

09:04.890 --> 09:17.600
inizia con una stringa e taglierà l'inizio e anche l'e-mail dell'utente può dire tagliare e tagliare la fine della stringa.

09:17.830 --> 09:20.800
Quindi, consolliamo il dialogo di log e

09:24.300 --> 09:33.460
vediamo cosa succede se lo copio e assicuriamoci di dichiarare queste variabili, quindi siate costanti e assicuratevi di sentire l'odore giusto della

09:33.490 --> 09:34.600
posta elettronica.

09:34.600 --> 09:39.220
Se lo copio ora e lo inserisco qui, non

09:42.230 --> 09:48.870
so se riesci a vedere, ma ora le mie stringhe non hanno spazi vuoti.

09:49.040 --> 09:57.890
Se controllo l'e-mail dell'utente qui, vedi che lo spazio vuoto è ancora lì, ma l'inizio della

09:58.820 --> 10:04.720
nuova e-mail dell'utente della stringa generata non avrà spazi vuoti.

10:04.840 --> 10:08.840
Bello e facile.

10:08.890 --> 10:10.750
Va bene, stiamo volando attraverso questi.

10:10.780 --> 10:11.760
Qual'è il prossimo.

10:11.770 --> 10:13.650
Ne restano solo alcuni.

10:13.720 --> 10:15.320
In realtà altri due rimasti.

10:15.400 --> 10:18.570
Il prossimo si chiama voci di modulo.

10:18.760 --> 10:23.950
Trasforma un elenco di coppie chiave-valore in un oggetto.

10:23.950 --> 10:29.260
Lascia che ti mostri cosa intendo chiariamo questo e commentiamo.

10:29.260 --> 10:30.440
Tutto questo.

10:30.880 --> 10:36.650
Magari portalo in fondo e concentrarti su questo.

10:36.770 --> 10:48.630
Quindi immagina di avere alcuni profili utente che riceviamo ma questi profili utente sono formattati nel modo

10:48.630 --> 10:49.560
sbagliato.

10:49.560 --> 10:56.850
Quindi diciamo un array e all'interno di un array abbiamo i profili utente di un gioco.

10:56.850 --> 11:07.330
Quindi dobbiamo chiamarlo comandante Tom come nome del giocatore e il comandante Tom ha 23 anni.

11:07.360 --> 11:20.700
Quindi abbiamo una serie di Derek Zealander e Derek Zealander è diciamo 40, rendiamola un

11:20.700 --> 11:23.960
po 'più grande.

11:24.110 --> 11:34.190
E poi finalmente abbiamo un array Hansel e Hansel ha 18 anni, quindi abbiamo questi profili utente, ma come gara non sono davvero

11:34.250 --> 11:36.100
utili in questo momento.

11:36.110 --> 11:44.720
Non sarebbe bello se possiamo convertirli in un oggetto in cui ogni nome utente è associato a un H.

11:45.320 --> 11:48.460
Bene, questo è esattamente ciò per cui vengono usate le voci.

11:48.740 --> 12:03.320
Facciamo semplicemente un oggetto punto o da voci, quindi dalle voci e dalle voci si riceverà un array

12:03.320 --> 12:05.150
come questo.

12:05.150 --> 12:13.320
Facciamo qui i profili utente e vediamo cosa succede combattendo.

12:13.340 --> 12:14.210
Copia questo

12:17.050 --> 12:18.350
codice incollalo qui.

12:20.100 --> 12:21.270
Ehi guarda quello.

12:21.480 --> 12:24.940
Ora otteniamo un oggetto con il comandante Tom.

12:24.940 --> 12:26.030
Ventitré.

12:26.040 --> 12:34.320
Derek Zealander ha una chiave e un valore di 40 e Hansel ha una chiave di Hansel e un valore di diciotto.

12:34.440 --> 12:41.700
Ora il nome potrebbe innescare qualcosa mentre lo guardi perché in Sì otto abbiamo parlato

12:42.570 --> 12:45.370
di qualcosa chiamato voci giusto.

12:45.720 --> 12:54.860
Le voci dei punti oggetto ci hanno permesso di fare esattamente la cosa opposta.

12:54.880 --> 13:04.540
Quindi, ad esempio, se ora questo era un oggetto, se ora inserisco voci su questo oggetto.

13:04.540 --> 13:07.150
Quindi copiamo e incolliamo gli

13:09.770 --> 13:13.100
aggiornamenti per ottenere esattamente quello che avevo originariamente.

13:13.130 --> 13:16.570
Quindi dalle voci il nome dalle voci viene semplicemente.

13:16.640 --> 13:18.880
Bene voci punto oggetto.

13:18.950 --> 13:19.310
Tutto ok.

13:19.310 --> 13:19.800
Tutto ok.

13:19.910 --> 13:21.310
L'ultimo lo prometto.

13:21.310 --> 13:22.500
E poi abbiamo finito.

13:22.640 --> 13:34.600
L'ultima parte è un aggiornamento di una funzionalità che abbiamo in JavaScript che è il blocco catch catch

13:34.600 --> 13:36.330
come questo.

13:36.390 --> 13:42.810
Ora questo blocco catch è qualcosa di cui parleremo molto di più quando entreremo nella

13:43.170 --> 13:45.530
parte asincrona javascript del corso.

13:45.780 --> 13:53.730
Ma essenzialmente il blocco try and cache in JavaScript ci consente di provare un pezzo di codice e se

13:53.730 --> 13:56.350
ci sono errori per catturarli.

13:56.400 --> 14:09.560
Quindi, per esempio, se ascolto diciamo quattro più cinque ed eseguo questo pezzo di codice, faccio clic su Esegui ottengo

14:09.670 --> 14:10.430
nove.

14:10.590 --> 14:15.970
È esattamente la stessa cosa che scriviamo quattro più cinque.

14:15.980 --> 14:23.810
L'unica differenza è che all'interno di questo blocco tribù stiamo dicendo javascript Ehi, prova questo e se ci

14:23.810 --> 14:29.110
sono errori sulla terza riga qui, fai qualcosa all'interno del blocco cache.

14:29.750 --> 14:44.580
Quindi potrei, ad esempio, dire che il punto dot della console ti ha incasinato e ora se lo faccio diciamo vero o vero più hi fi copia e

14:45.090 --> 14:56.010
incolla questo ed eseguo questo codice divento davvero alto a causa di qualcosa che abbiamo visto prima che è la

14:56.010 --> 14:57.830
coercizione di tipo.

14:58.350 --> 15:07.470
Quindi ha provato questo in javascript che è javascript valido perché si trasforma in una stringa e lo combina

15:07.470 --> 15:08.500
con high.

15:08.640 --> 15:12.230
Ma se diciamo, facciamo una variabile che non abbiamo mai visto prima.

15:12.240 --> 15:21.770
Quindi, invece di vero, supponiamo di avere un fuoco variabile bob che esegue questo, arrivo al blocco della cache che dice che

15:22.040 --> 15:29.990
hai incasinato perché mentre questo attraversa un errore e non appena genera un errore, cattura ed ecco la

15:29.990 --> 15:30.710
cosa.

15:30.710 --> 15:39.050
In realtà hai visto una nuova funzionalità qui in ESPN perché nel giorno precedente a Sì 10,

15:39.050 --> 15:47.280
affinché questo codice potesse effettivamente catturare, dovevi passare un oggetto o un parametro di errore.

15:47.280 --> 15:49.050
Quindi avrei potuto chiamarlo come volevo.

15:49.110 --> 15:55.850
Quindi ho dovuto fare un errore del genere in modo da poter dire un errore.

15:56.040 --> 16:08.080
Quindi, se copio questo aggiornamento e diamo Bob qui in modo che si verifichi un errore, ti faccio incasinare ma poi prendo anche

16:08.080 --> 16:12.150
l'errore che è un errore di riferimento.

16:12.250 --> 16:13.420
Bob non è definito.

16:14.260 --> 16:21.970
Quindi, prima che dovevamo passare un parametro, altrimenti l'intero blocco di codice, anche se funzionava correttamente, avrebbe effettivamente un

16:22.390 --> 16:25.840
errore perché non gli abbiamo passato il parametro.

16:25.840 --> 16:32.260
Sì, Stan, abbiamo un aggiornamento in cui non sei costretto a usare quel parametro se non vuoi.

16:32.290 --> 16:37.210
Ancora una volta questo è qualcosa che tratteremo più avanti nel corso quando parliamo

16:39.260 --> 16:44.190
di javascript asincrono oh ragazzo che sembrava molto, ma intendo che non era molta pioggia.

16:44.330 --> 16:46.760
Bello e facile bello e semplice.

16:46.760 --> 16:48.670
Ci vediamo nel prossimo video.

16:48.670 --> 16:49.130
Ciao ciao.

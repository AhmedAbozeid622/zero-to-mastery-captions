WEBVTT

00:01.370 --> 00:10.140
E torniamo a parlare di nuovo di array nella prima sezione quando abbiamo parlato di array, abbiamo detto che sembravano qualcosa di simile

00:10.190 --> 00:11.980
a queste parentesi quadre

00:15.010 --> 00:18.230
e che possiamo mettere tutto ciò che vogliamo.

00:18.220 --> 00:20.920
Abbiamo appena inserito alcuni numeri qui.

00:21.100 --> 00:27.340
Quindi questi sono array e abbiamo parlato del fatto che possiamo fare quattro loop con loro.

00:27.340 --> 00:32.590
Possiamo fare per ognuno con loro che era nuovo nella mia sceneggiatura cinque.

00:32.720 --> 00:35.390
E oggi ne impareremo qualche altro.

00:35.540 --> 00:41.990
Ma prima di farlo ricordiamo come funziona il For Each.

00:42.030 --> 00:47.200
Diciamo che vogliamo moltiplicare ogni singolo numero nell'array.

00:47.430 --> 01:01.860
Possiamo solo ricordare a Konst ora che possiamo semplicemente usare la nostra nuova sintassi E6 e possiamo dire che il nuovo array è uguale al punto dell'array

01:03.240 --> 01:08.170
per ciascuno e si legge bene per ogni array.

01:09.290 --> 01:15.750
Useremo un numero e useremo di nuovo come funzione.

01:15.980 --> 01:17.690
Niente più parole funzione.

01:17.690 --> 01:28.290
Tutto sembra più bello in questo modo con la freccia grassa e per ogni numero nell'array numero Whalsay

01:29.040 --> 01:34.020
per due volte, quindi moltiplica tutto per due.

01:34.020 --> 01:38.810
Ora vedremo cosa ci dà il registro della console.

01:39.830 --> 01:47.700
Sei indefinito.

01:47.860 --> 01:50.250
Bene perché non è così.

01:50.260 --> 01:58.510
Per ognuno funziona bene per ognuno dice solo che mi sposterò su questi elementi e moltiplicherò un numero

01:58.510 --> 02:02.280
per due, ma non stiamo cambiando l'array.

02:02.380 --> 02:08.500
Se guardiamo l'array in questo momento bene, è sempre la stessa cosa da 1 a 10 16.

02:08.700 --> 02:14.190
Stiamo solo moltiplicando casualmente i numeri per due, ma non li stiamo memorizzando da nessuna parte.

02:14.830 --> 02:24.940
Se vogliamo fare quello che stiamo facendo, dobbiamo dire Konst double e diremo che double

02:25.600 --> 02:31.760
è un array e quindi double dot push.

02:31.820 --> 02:38.410
Quindi stiamo spingendo sull'array mentre lo percorriamo più volte.

02:38.480 --> 02:40.210
Ora vediamo cosa ci dà il doppio.

02:43.440 --> 02:48.760
Salvo un aggiornamento e lo guardo.

02:48.820 --> 02:52.500
Ne ottengo due per 20 32.

02:52.570 --> 02:53.160
OK.

02:53.380 --> 03:05.910
Ora quelli di cui parleremo oggi sono il filtro delle mappe e la riduzione. Direi che questi tre sono

03:05.910 --> 03:11.810
probabilmente i metodi più importanti che userete oggi.

03:11.880 --> 03:17.340
Javascript sono super utili, quindi inizia davvero a conoscerli.

03:17.390 --> 03:25.610
E ogni volta che pensi di fare una sorta di ciclo molto probabilmente vorrai fare uno di questi tre.

03:25.680 --> 03:32.850
Cominciamo con la mappa il modo sopra descritto di raddoppiare ogni cosa nell'array e

03:32.850 --> 03:52.430
creare bene un nuovo array con la mappa, possiamo fare il numero di mappe di punti di parata di array di mappe di parata è il numero di volte e il modo in cui funziona la mappa è

03:52.490 --> 04:01.720
che devi sempre restituire qualcosa perché ciò che è diverso per mabbe di quanto non lo sia per

04:01.930 --> 04:10.690
ogni pozzo per ogni singolo loop è qualcosa e fa esattamente quello che dice la funzione rispetto

04:10.690 --> 04:11.530
all'array.

04:11.680 --> 04:19.330
Siamo in grado di fare ciò che non potremmo fare con ciascuno di essi, che viene ripetuto su ogni elemento per ogni numero

04:19.330 --> 04:21.100
e restituisce un nuovo array.

04:21.110 --> 04:22.310
Lascia che ti mostri cosa intendo.

04:22.790 --> 04:25.270
Ogni volta che l'array esegue un loop.

04:25.310 --> 04:29.110
Diciamo che qui il primo è il numero uno.

04:29.310 --> 04:36.340
Restituiamo 1 volte 2 che viene messo nell'array map che ora è 2.

04:36.450 --> 04:39.370
E poi passiamo al numero successivo per 2 volte 2.

04:39.390 --> 04:46.290
Ora viene aggiunto all'array 10 volte 2 viene aggiunto all'array e 16 volte 2 viene aggiunto all'array.

04:46.300 --> 04:47.740
Ecco perché lo restituiamo.

04:47.860 --> 04:53.980
E facendo questo se abbiamo l'array di mappe di log del

04:57.520 --> 05:00.460
cane Konsole e aggiorniamo qui.

05:00.850 --> 05:07.890
E qui abbiamo una parentesi di chiusura. Proviamo di nuovo.

05:08.010 --> 05:09.900
Vedi quella matrice di mappe.

05:09.900 --> 05:23.650
Quindi la prima riga è doppia e la seconda è la knackery le nominerà solo per conoscere la differenza.

05:23.670 --> 05:26.760
E rifacciamo tutto da capo.

05:27.260 --> 05:31.340
A proposito, ti stai chiedendo perché sto rinfrescando invece di copiarlo e incollarlo qui.

05:31.350 --> 05:38.570
Bene perché perché stiamo usando Konst sta dicendo che l'array è già stato dichiarato, quindi

05:38.580 --> 05:39.960
devo aggiornare.

05:40.290 --> 05:41.520
Ma eccoti qua.

05:41.520 --> 05:47.830
Per ogni mappa che guarda questi due sembrano entrambi fare la stessa cosa.

05:48.720 --> 05:54.570
Ma c'è una differenza critica tra la mappa e per ognuna e sono qui per dirti che

05:54.570 --> 06:00.160
ogni volta che vuoi fare un ciclo semplice, esegui qualche azione su qualcosa come un array.

06:00.450 --> 06:06.980
Si desidera utilizzare la mappa sopra per ciascuno con per ciascuno l'operazione potrebbe non fare nulla.

06:07.020 --> 06:15.310
Puoi semplicemente lasciare questo completamente vuoto o fare il registro di Konsole perché tutto per ogni problema è iterare che

06:15.350 --> 06:24.550
andrà uno a uno a scorrere su una raccolta di elementi come da 1 a 10 e 16 e applicare qualsiasi operazione a

06:24.550 --> 06:27.440
cui diciamo su ogni elemento .

06:27.460 --> 06:31.800
Ora la mappa d'altra parte ha una restrizione sull'operazione.

06:31.930 --> 06:35.230
Si aspetta che l'operazione restituisca un elemento.

06:35.230 --> 06:42.580
Quindi con map with per ognuno puoi avere più righe di codice che fanno tutte queste cose folli rispetto a map

06:42.970 --> 06:43.740
con map.

06:43.750 --> 06:46.900
Hai sempre un elemento di ritorno.

06:46.930 --> 06:54.280
La mappa scorre nuovamente su una raccolta di elementi applicando l'operazione su ciascun

06:54.730 --> 07:00.510
elemento e infine memorizzando il risultato di ogni invocazione dell'operazione.

07:00.520 --> 07:06.970
Questo è questo in un'altra raccolta che è l'array di mappe.

07:07.010 --> 07:12.920
In altre parole, map trasforma l'array.

07:12.920 --> 07:22.490
Crea un nuovo array che è un array di mappe rispetto a ciascuno di essi, che esegue solo un mucchio di

07:22.490 --> 07:27.620
azioni basate sull'array e quali azioni sono realmente non limitate.

07:27.620 --> 07:34.230
Se vogliamo restituire un nuovo array, dobbiamo creare il nostro array e poi spingere.

07:34.370 --> 07:39.260
E potresti notare qui qualcosa di cui abbiamo parlato nell'ultima

07:39.260 --> 07:49.990
sezione quando abbiamo parlato di funzioni avanzate e che è l'idea degli effetti collaterali se torniamo con foreach possiamo fare un sacco di effetti

07:49.990 --> 07:52.010
collaterali all'interno della funzione.

07:52.210 --> 08:00.650
Puoi legge Konsole, puoi creare un nuovo array che puoi spingere verso quell'array che puoi restituire indefinito.

08:00.650 --> 08:07.960
Hai visto che quando abbiamo fatto la prima volta per ciascuno o anche ora non stiamo davvero restituendo nulla.

08:08.010 --> 08:12.120
Quindi stiamo tornando indefiniti rispetto a una mappa.

08:12.220 --> 08:15.700
Tutti questi effetti collaterali sono teoricamente spariti.

08:15.840 --> 08:19.190
E perché con una mappa dobbiamo tornare.

08:19.240 --> 08:22.800
Lascia che ti mostri se non torno qui, vediamo cosa succede.

08:30.910 --> 08:34.280
Ottengo mappa non definita non definita non definita non definita.

08:34.540 --> 08:37.660
Immediatamente sappiamo che stiamo facendo qualcosa di sbagliato che dobbiamo tornare.

08:38.140 --> 08:47.230
E come abbiamo accennato nella sezione precedente, ora abbiamo creato una funzione pura in cui non ci sono dubbi sul fatto che

08:47.230 --> 08:48.790
torneremo o meno.

08:49.660 --> 08:59.130
Abbiamo input una funzione senza effetti collaterali che semplicemente restituisce un valore.

08:59.180 --> 09:01.350
Ancora una volta un concetto molto importante.

09:01.370 --> 09:05.990
Vogliamo mantenere le cose agendo nel modo previsto.

09:06.080 --> 09:13.310
Non vogliamo avere un pezzo di codice che risieda su un sito Web, diciamo per quattro

09:13.310 --> 09:21.350
anni e qualcuno si avvicini che non lo conosce intimamente e all'improvviso si verificano tutti questi effetti collaterali

09:21.500 --> 09:23.950
di cui non sanno .

09:24.080 --> 09:31.540
Ancora una volta vogliamo scrivere semplici Foxton semplici ed è ciò che la mappa ci consente di fare.

09:31.650 --> 09:34.980
E l'altra cosa importante è che non stiamo cambiando l'array.

09:34.980 --> 09:40.830
Questo array rimane lo stesso con la matematica perché stiamo sempre facendo una nuova copia

09:40.830 --> 09:44.420
dell'array e non stiamo mai mutando i dati.

09:44.490 --> 09:44.910
Tutto ok.

09:44.910 --> 09:46.090
Quindi quella era la mappa.

09:46.200 --> 09:48.100
Riportiamo qui il ritorno.

09:48.420 --> 09:51.940
E riportiamo il console.

09:51.960 --> 09:59.160
Voglio anche mostrarti che quando hai un solo parametro con una

09:59.640 --> 10:04.400
funzione aria puoi effettivamente evitare le parentesi.

10:04.560 --> 10:11.410
E ancora perché stiamo tornando e stiamo solo tornando una sola riga qui possiamo fare una scorciatoia

10:11.410 --> 10:12.970
che è proprio

10:16.290 --> 10:19.020
questa pulizia della casa che fa previsioni.

10:19.250 --> 10:24.050
Proviamolo di nuovo.

10:24.060 --> 10:24.490
Ecco qua

10:24.490 --> 10:26.070
Tutto sembra carino.

10:26.070 --> 10:35.280
Guarda quella differenza tra la mappa e la per ognuna la prossima che ti mostrerò è il filtro.

10:35.600 --> 10:39.460
Ora con filter possiamo dire array di filtri.

10:40.310 --> 10:51.230
E come suggerisce il nome, possiamo filtrare il nostro array con una condizione nel nostro caso, possiamo dire che Blits restituisce tutti

10:51.350 --> 11:00.010
gli elementi nell'array che sono sopra e quindi possiamo dire che il numero è maggiore di 5.

11:00.310 --> 11:11.360
E come con map restituisce un nuovo array, quindi dobbiamo restituire qualcosa perché l'array del filtro conterrà

11:11.360 --> 11:12.890
tali informazioni.

11:12.890 --> 11:23.620
Quindi il modo in cui leggi questo è filtrare questo Saray che è qui mentre stai andando uno per uno, quindi

11:24.190 --> 11:31.150
un numero sarà il primo un ritorno è uno maggiore di 5.

11:31.190 --> 11:34.100
In questo caso dirà che è falso.

11:34.310 --> 11:38.290
Quindi non lo aggiungeremo all'array di filtri.

11:39.090 --> 11:43.350
Quindi iterate a due è troppo maggiore di cinque.

11:43.350 --> 11:44.580
No è falso.

11:44.580 --> 11:50.940
Quindi non andrà nell'array di filtri 10 maggiore di 5.

11:51.390 --> 11:52.550
Si è buono.

11:52.560 --> 11:57.520
Dieci andrà nell'array di filtri ed è 16 maggiore di 5.

11:57.870 --> 11:58.350
Sì.

11:58.500 --> 12:03.100
Quindi 16 entrerà nell'array.

12:03.300 --> 12:08.070
E ancora perché è solo una riga che possiamo fare in forma breve qui.

12:11.410 --> 12:19.450
E ora se cancelliamo il registro e diremo array di filtri di filtro.

12:22.590 --> 12:39.920
E aggiorna otteniamo il filtro contenente 10 e 16 se facciamo uguale a 5 mentre in quel caso otteniamo un array vuoto perché

12:39.920 --> 12:43.850
niente è uguale a cinque.

12:43.910 --> 12:46.000
Quindi puoi inserire qualsiasi condizione tu voglia qui.

12:46.010 --> 12:51.480
Se ha avuto forza e vuoi vedere se contiene una parola ciao Beh, puoi farlo anche tu.

12:51.560 --> 12:56.210
Tutto quello che devi fare è restituire vero o falso se restituisce falso.

12:56.210 --> 13:02.050
Non andrà nell'array se restituisce true mentre andrà nell'array.

13:02.050 --> 13:04.210
Molto bello, molto utile.

13:04.500 --> 13:05.430
Cos'altro abbiamo.

13:05.440 --> 13:11.550
Bene, l'ultimo che voglio mostrarti è ridurre e questo è davvero molto potente, puoi fare molto con

13:11.550 --> 13:12.250
Reduce.

13:12.330 --> 13:16.910
Puoi effettivamente fare filtri e mappature con riduci.

13:17.040 --> 13:19.110
Quindi è un metodo davvero molto potente.

13:19.410 --> 13:22.470
Ma ti mostrerò un modo semplice per iniziare.

13:23.910 --> 13:27.810
Bene, stiamo andando a dire

13:30.590 --> 13:43.270
che Konst riduce l'array che chiama e di nuovo questo restituisce un nuovo array che salviamo riduci

13:43.300 --> 13:50.080
e riduci prende qualcosa chiamato accumulatore e il numero.

13:50.120 --> 13:52.490
Ora ovviamente questo può essere qualsiasi nome.

13:52.510 --> 13:58.190
A volte vedrai un CC per un accumulatore, lo lasceremo così per ora, così puoi vedere che sappiamo qual

13:58.190 --> 13:59.180
è il numero.

13:59.180 --> 14:05.860
Il numero è compreso tra 1 e 10 e 16, ma cos'è l'accumulatore.

14:06.230 --> 14:15.140
Bene l'accumulatore è qualcosa in cui possiamo archiviare le informazioni che accadono nel corpo della funzione.

14:15.140 --> 14:25.180
Lasciami spiegare l'accumulatore più il numero e ancora perché riduciamo la restituzione di un array.

14:25.260 --> 14:27.930
Dobbiamo restituire un valore.

14:28.210 --> 14:36.030
E quello che stiamo dicendo qui è che ogni volta che iterate Quindi diciamo il primo giro.

14:36.060 --> 14:42.220
Hai l'accumulatore numero uno più il numero uno uguale.

14:42.310 --> 14:49.050
Diciamo che se l'accumulatore è zero allora tutti uguali a 1 ora zero più uno uguale a 1.

14:49.270 --> 14:57.160
Quando arriva 2 facciamo 1 più 2 perché l'accumulatore ricorda cosa c'era prima

14:57.160 --> 15:03.260
e poi 10 arriva e vai tre più 10.

15:03.270 --> 15:05.540
Ora cos'è l'accumulatore.

15:05.540 --> 15:10.800
Non lo abbiamo definito da nessuna parte in redos dopo la funzione.

15:11.010 --> 15:14.220
Hai un secondo parametro.

15:14.340 --> 15:20.460
E qui possiamo specificare cosa vogliamo che il nostro accumulatore abbia come protagonista il valore predefinito.

15:20.910 --> 15:23.740
Nel nostro caso diciamo zero.

15:23.740 --> 15:28.190
Ora, se faccio il dialogo di Konsole, riduci

15:31.000 --> 15:32.890
e riduci.

15:33.220 --> 15:34.370
Vediamo cosa succede.

15:39.150 --> 15:48.940
Riduciamo 29 perché 10 più 16 è 26 più tre è 29.

15:48.980 --> 16:05.560
Se ho cambiato questo in 5 e lo copio e riprovo otteniamo 34 perché il numero iniziale è ora cinque.

16:05.600 --> 16:06.570
Molto bello.

16:06.610 --> 16:07.550
Quindi è tutto.

16:07.660 --> 16:13.820
Voglio che ricordi questi tre metodi perché li userai molto nella tua carriera.

16:13.810 --> 16:15.490
Sono molto molto utili.

16:15.550 --> 16:24.290
Sono puri, il che significa che ogni volta che eseguiamo un'operazione qualunque input ci venga restituito restituisce sempre un

16:24.290 --> 16:24.940
valore.

16:24.980 --> 16:28.610
E non ci sono effetti collaterali.

16:28.690 --> 16:33.270
E come puoi vedere sono molto facili e facili da leggere.

16:33.400 --> 16:36.830
Quindi abituati a loro e buona fortuna con gli

16:36.880 --> 16:40.130
esercizi dopo questo video. Ci vediamo nel prossimo ciao.
